{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, inject, INJECTOR, ɵglobal, ErrorHandler, Optional, SkipSelf, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport * as i5 from '@ngxs/store/internals';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY, InitialState } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, isObservable, queueScheduler } from 'rxjs';\nimport { filter, map, share, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, observeOn, distinctUntilChanged, tap, startWith, pairwise } from 'rxjs/operators';\nfunction throwStateNameError(name) {\n  throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n  throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n  throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n  throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n  throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n  throw new Error('Selectors only work on methods.');\n}\nfunction getZoneWarningMessage() {\n  return 'Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' + 'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' + 'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })';\n}\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n  return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction throwSelectFactoryNotConnectedError() {\n  throw new Error('You have forgotten to import the NGXS module!');\n}\nfunction throwPatchingArrayError() {\n  throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n  throw new Error('Patching primitives is not supported.');\n}\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n  constructor(_ngZone, _platformId) {\n    this._ngZone = _ngZone;\n    this._platformId = _platformId;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      verifyZoneIsNotNooped(_ngZone);\n    }\n  }\n  enter(func) {\n    if (isPlatformServer(this._platformId)) {\n      return this.runInsideAngular(func);\n    }\n    return this.runOutsideAngular(func);\n  }\n  leave(func) {\n    return this.runInsideAngular(func);\n  }\n  runInsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return func();\n    }\n    return this._ngZone.run(func);\n  }\n  runOutsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return this._ngZone.runOutsideAngular(func);\n    }\n    return func();\n  }\n}\n/** @nocollapse */\nDispatchOutsideZoneNgxsExecutionStrategy.ɵfac = function DispatchOutsideZoneNgxsExecutionStrategy_Factory(t) {\n  return new (t || DispatchOutsideZoneNgxsExecutionStrategy)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */\nDispatchOutsideZoneNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DispatchOutsideZoneNgxsExecutionStrategy,\n  factory: DispatchOutsideZoneNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DispatchOutsideZoneNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n// Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\nfunction verifyZoneIsNotNooped(ngZone) {\n  // `NoopNgZone` is not exposed publicly as it doesn't expect\n  // to be used outside of the core Angular code, thus we just have\n  // to check if the zone doesn't extend or instanceof `NgZone`.\n  if (ngZone instanceof NgZone) {\n    return;\n  }\n  console.warn(getZoneWarningMessage());\n}\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nconst META_KEY = 'NGXS_META';\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n  constructor() {\n    /**\n     * Defining the default state before module initialization\n     * This is convenient if we need to create a define our own set of states.\n     * @deprecated will be removed after v4\n     * (default: {})\n     */\n    this.defaultsState = {};\n    /**\n     * Defining shared selector options\n     */\n    this.selectorOptions = {\n      injectContainerState: true,\n      suppressErrors: true // TODO: default is true in v3, will change in v4\n    };\n\n    this.compatibility = {\n      strictContentSecurityPolicy: false\n    };\n    this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n  }\n}\n/** @nocollapse */\nNgxsConfig.ɵfac = function NgxsConfig_Factory(t) {\n  return new (t || NgxsConfig)();\n};\n/** @nocollapse */\nNgxsConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsConfig,\n  factory: NgxsConfig.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsConfig, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n}\nclass NoopNgxsExecutionStrategy {\n  enter(func) {\n    return func();\n  }\n  leave(func) {\n    return func();\n  }\n}\n/** @nocollapse */\nNoopNgxsExecutionStrategy.ɵfac = function NoopNgxsExecutionStrategy_Factory(t) {\n  return new (t || NoopNgxsExecutionStrategy)();\n};\n/** @nocollapse */\nNoopNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NoopNgxsExecutionStrategy,\n  factory: NoopNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NoopNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n */\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(INJECTOR);\n    const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n    return executionStrategy ? injector.get(executionStrategy) : injector.get(typeof ɵglobal.Zone !== 'undefined' ? DispatchOutsideZoneNgxsExecutionStrategy : NoopNgxsExecutionStrategy);\n  }\n});\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ensureStoreMetadata$1(target) {\n  if (!target.hasOwnProperty(META_KEY)) {\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n      children: []\n    };\n    Object.defineProperty(target, META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return getStoreMetadata$1(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction getStoreMetadata$1(target) {\n  return target[META_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ensureSelectorMetadata$1(target) {\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n    const defaultMetadata = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions: () => ({})\n    };\n    Object.defineProperty(target, SELECTOR_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return getSelectorMetadata$1(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction getSelectorMetadata$1(target) {\n  return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n  const copyOfPaths = paths.slice();\n  return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n  let expr = seg;\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n  const fn = new Function('store', 'return ' + expr + ';');\n  return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nfunction propGetter(paths, config) {\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n  const findName = stateClass => {\n    const meta = stateClasses.find(g => g === stateClass);\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n      throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n    }\n    return meta[META_KEY].name;\n  };\n  return stateClasses.reduce((result, stateClass) => {\n    const {\n      name,\n      children\n    } = stateClass[META_KEY];\n    result[name] = (children || []).map(findName);\n    return result;\n  }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n  return states.reduce((result, stateClass) => {\n    const meta = stateClass[META_KEY];\n    result[meta.name] = stateClass;\n    return result;\n  }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, newObj = {}) {\n  const visit = (child, keyToFind) => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n    return null;\n  };\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n  return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n  const sorted = [];\n  const visited = {};\n  const visit = (name, ancestors = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n    ancestors.push(name);\n    visited[name] = true;\n    graph[name].forEach(dep => {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n      if (visited[dep]) {\n        return;\n      }\n      visit(dep, ancestors.slice(0));\n    });\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n  Object.keys(graph).forEach(k => visit(k));\n  return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nfunction isObject$1(obj) {\n  return typeof obj === 'object' && obj !== null || typeof obj === 'function';\n}\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n  if (action.constructor && action.constructor.type) {\n    return action.constructor.type;\n  } else {\n    return action.type;\n  }\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n  const type1 = getActionTypeFromInstance(action1);\n  return function (action2) {\n    return type1 === getActionTypeFromInstance(action2);\n  };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n  obj = Object.assign({}, obj);\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n */\nconst isObject = item => {\n  return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * @param base base object onto which `sources` will be applied\n */\nconst mergeDeep = (base, ...sources) => {\n  if (!sources.length) return base;\n  const source = sources.shift();\n  if (isObject(base) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!base[key]) Object.assign(base, {\n          [key]: {}\n        });\n        mergeDeep(base[key], source[key]);\n      } else {\n        Object.assign(base, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(base, ...sources);\n};\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n  return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"DISPATCHED\" /* Dispatched */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"SUCCESSFUL\" /* Successful */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"CANCELED\" /* Canceled */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n  const allowedStatuses = [\"SUCCESSFUL\" /* Successful */, \"CANCELED\" /* Canceled */, \"ERRORED\" /* Errored */];\n\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"ERRORED\" /* Errored */]);\n}\n\nfunction ofActionOperator(allowedTypes, statuses,\n// This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return function (o) {\n    return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n  };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n  return filter(ctx => {\n    const actionType = getActionTypeFromInstance(ctx.action);\n    const typeMatch = allowedTypes[actionType];\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\nfunction mapActionResult() {\n  return map(({\n    action,\n    status,\n    error\n  }) => {\n    return {\n      action,\n      result: {\n        successful: \"SUCCESSFUL\" /* Successful */ === status,\n        canceled: \"CANCELED\" /* Canceled */ === status,\n        error\n      }\n    };\n  });\n}\nfunction mapAction() {\n  return map(ctx => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n  return types.reduce((filterMap, klass) => {\n    filterMap[getActionTypeFromInstance(klass)] = true;\n    return filterMap;\n  }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n  return statuses.reduce((filterMap, status) => {\n    filterMap[status] = true;\n    return filterMap;\n  }, {});\n}\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n  return source => {\n    return new Observable(sink => {\n      return source.subscribe({\n        next(value) {\n          ngxsExecutionStrategy.leave(() => sink.next(value));\n        },\n        error(error) {\n          ngxsExecutionStrategy.leave(() => sink.error(error));\n        },\n        complete() {\n          ngxsExecutionStrategy.leave(() => sink.complete());\n        }\n      });\n    });\n  };\n}\nclass InternalNgxsExecutionStrategy {\n  constructor(_executionStrategy) {\n    this._executionStrategy = _executionStrategy;\n  }\n  enter(func) {\n    return this._executionStrategy.enter(func);\n  }\n  leave(func) {\n    return this._executionStrategy.leave(func);\n  }\n}\n/** @nocollapse */\nInternalNgxsExecutionStrategy.ɵfac = function InternalNgxsExecutionStrategy_Factory(t) {\n  return new (t || InternalNgxsExecutionStrategy)(i0.ɵɵinject(NGXS_EXECUTION_STRATEGY));\n};\n/** @nocollapse */\nInternalNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalNgxsExecutionStrategy,\n  factory: InternalNgxsExecutionStrategy.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalNgxsExecutionStrategy, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_EXECUTION_STRATEGY]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._itemQueue = [];\n    this._busyPushingNext = false;\n  }\n  next(value) {\n    if (this._busyPushingNext) {\n      this._itemQueue.unshift(value);\n      return;\n    }\n    this._busyPushingNext = true;\n    super.next(value);\n    while (this._itemQueue.length > 0) {\n      const nextValue = this._itemQueue.pop();\n      super.next(nextValue);\n    }\n    this._busyPushingNext = false;\n  }\n}\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends OrderedSubject {\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n/** @nocollapse */\nInternalActions.ɵfac = /* @__PURE__ */function () {\n  let ɵInternalActions_BaseFactory;\n  return function InternalActions_Factory(t) {\n    return (ɵInternalActions_BaseFactory || (ɵInternalActions_BaseFactory = i0.ɵɵgetInheritedFactory(InternalActions)))(t || InternalActions);\n  };\n}();\n/** @nocollapse */\nInternalActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalActions,\n  factory: InternalActions.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalActions, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n  constructor(internalActions$, internalExecutionStrategy) {\n    const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy),\n    // The `InternalActions` subject emits outside of the Angular zone.\n    // We have to re-enter the Angular zone for any incoming consumer.\n    // The `share()` operator reduces the number of change detections.\n    // This would call leave only once for any stream emission across all active subscribers.\n    share());\n    super(observer => {\n      const childSubscription = sharedInternalActions$.subscribe({\n        next: ctx => observer.next(ctx),\n        error: error => observer.error(error),\n        complete: () => observer.complete()\n      });\n      observer.add(childSubscription);\n    });\n  }\n}\n/** @nocollapse */\nActions.ɵfac = function Actions_Factory(t) {\n  return new (t || Actions)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalNgxsExecutionStrategy));\n};\n/** @nocollapse */\nActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Actions,\n  factory: Actions.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Actions, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: InternalActions\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }];\n  }, null);\n})();\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nconst compose = funcs => (...args) => {\n  const curr = funcs.shift();\n  return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\nfunction ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {\n  return source => {\n    let subscribed = false;\n    source.subscribe({\n      error: error => {\n        // Do not trigger change detection for a microtask. This depends on the execution\n        // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`\n        // leaves the Angular zone.\n        ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {\n          if (!subscribed) {\n            ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));\n          }\n        }));\n      }\n    });\n    return new Observable(subscriber => {\n      subscribed = true;\n      return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);\n    });\n  };\n}\nclass InternalErrorReporter {\n  constructor(_injector) {\n    this._injector = _injector;\n    /** Will be set lazily to be backward compatible. */\n    this._errorHandler = null;\n  }\n  reportErrorSafely(error) {\n    if (this._errorHandler === null) {\n      this._errorHandler = this._injector.get(ErrorHandler);\n    }\n    // The `try-catch` is used to avoid handling the error twice. Suppose we call\n    // `handleError` which re-throws the error internally. The re-thrown error will\n    // be caught by zone.js which will then get to the `zone.onError.emit()` and the\n    // `onError` subscriber will call `handleError` again.\n    try {\n      this._errorHandler.handleError(error);\n    } catch (_a) {}\n  }\n}\n/** @nocollapse */\nInternalErrorReporter.ɵfac = function InternalErrorReporter_Factory(t) {\n  return new (t || InternalErrorReporter)(i0.ɵɵinject(i0.Injector));\n};\n/** @nocollapse */\nInternalErrorReporter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalErrorReporter,\n  factory: InternalErrorReporter.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalErrorReporter, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass StateStream extends BehaviorSubject {\n  constructor() {\n    super({});\n  }\n  ngOnDestroy() {\n    // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n    // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n    // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n    this.complete();\n  }\n}\n/** @nocollapse */\nStateStream.ɵfac = function StateStream_Factory(t) {\n  return new (t || StateStream)();\n};\n/** @nocollapse */\nStateStream.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateStream,\n  factory: StateStream.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateStream, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\nclass PluginManager {\n  constructor(_parentManager, _pluginHandlers) {\n    this._parentManager = _parentManager;\n    this._pluginHandlers = _pluginHandlers;\n    this.plugins = [];\n    this.registerHandlers();\n  }\n  get rootPlugins() {\n    return this._parentManager && this._parentManager.plugins || this.plugins;\n  }\n  registerHandlers() {\n    const pluginHandlers = this.getPluginHandlers();\n    this.rootPlugins.push(...pluginHandlers);\n  }\n  getPluginHandlers() {\n    const handlers = this._pluginHandlers || [];\n    return handlers.map(plugin => plugin.handle ? plugin.handle.bind(plugin) : plugin);\n  }\n}\n/** @nocollapse */\nPluginManager.ɵfac = function PluginManager_Factory(t) {\n  return new (t || PluginManager)(i0.ɵɵinject(PluginManager, 12), i0.ɵɵinject(NGXS_PLUGINS, 8));\n};\n/** @nocollapse */\nPluginManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PluginManager,\n  factory: PluginManager.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PluginManager, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: PluginManager,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_PLUGINS]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {}\n/** @nocollapse */\nInternalDispatchedActionResults.ɵfac = /* @__PURE__ */function () {\n  let ɵInternalDispatchedActionResults_BaseFactory;\n  return function InternalDispatchedActionResults_Factory(t) {\n    return (ɵInternalDispatchedActionResults_BaseFactory || (ɵInternalDispatchedActionResults_BaseFactory = i0.ɵɵgetInheritedFactory(InternalDispatchedActionResults)))(t || InternalDispatchedActionResults);\n  };\n}();\n/** @nocollapse */\nInternalDispatchedActionResults.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalDispatchedActionResults,\n  factory: InternalDispatchedActionResults.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatchedActionResults, [{\n    type: Injectable\n  }], null, null);\n})();\nclass InternalDispatcher {\n  constructor(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._pluginManager = _pluginManager;\n    this._stateStream = _stateStream;\n    this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n    this._internalErrorReporter = _internalErrorReporter;\n  }\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n    return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));\n  }\n  dispatchByEvents(actionOrActions) {\n    if (Array.isArray(actionOrActions)) {\n      if (actionOrActions.length === 0) return of(this._stateStream.getValue());\n      return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n    } else {\n      return this.dispatchSingle(actionOrActions);\n    }\n  }\n  dispatchSingle(action) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const type = getActionTypeFromInstance(action);\n      if (!type) {\n        const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n        return throwError(error);\n      }\n    }\n    const prevState = this._stateStream.getValue();\n    const plugins = this._pluginManager.plugins;\n    return compose([...plugins, (nextState, nextAction) => {\n      if (nextState !== prevState) {\n        this._stateStream.next(nextState);\n      }\n      const actionResult$ = this.getActionResultStream(nextAction);\n      actionResult$.subscribe(ctx => this._actions.next(ctx));\n      this._actions.next({\n        action: nextAction,\n        status: \"DISPATCHED\" /* Dispatched */\n      });\n      return this.createDispatchObservable(actionResult$);\n    }])(prevState, action).pipe(shareReplay());\n  }\n  getActionResultStream(action) {\n    return this._actionResults.pipe(filter(ctx => ctx.action === action && ctx.status !== \"DISPATCHED\" /* Dispatched */), take(1), shareReplay());\n  }\n  createDispatchObservable(actionResult$) {\n    return actionResult$.pipe(exhaustMap(ctx => {\n      switch (ctx.status) {\n        case \"SUCCESSFUL\" /* Successful */:\n          return of(this._stateStream.getValue());\n        case \"ERRORED\" /* Errored */:\n          return throwError(ctx.error);\n        default:\n          return EMPTY;\n      }\n    })).pipe(shareReplay());\n  }\n}\n/** @nocollapse */\nInternalDispatcher.ɵfac = function InternalDispatcher_Factory(t) {\n  return new (t || InternalDispatcher)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(PluginManager), i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(InternalErrorReporter));\n};\n/** @nocollapse */\nInternalDispatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalDispatcher,\n  factory: InternalDispatcher.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatcher, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: InternalActions\n    }, {\n      type: InternalDispatchedActionResults\n    }, {\n      type: PluginManager\n    }, {\n      type: StateStream\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }, {\n      type: InternalErrorReporter\n    }];\n  }, null);\n})();\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = o => {\n  Object.freeze(o);\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};\n\n/**\n * State Context factory class\n * @ignore\n */\nclass InternalStateOperations {\n  constructor(_stateStream, _dispatcher, _config) {\n    this._stateStream = _stateStream;\n    this._dispatcher = _dispatcher;\n    this._config = _config;\n  }\n  /**\n   * Returns the root state operators.\n   */\n  getRootStateOperations() {\n    const rootStateOperations = {\n      getState: () => this._stateStream.getValue(),\n      setState: newState => this._stateStream.next(newState),\n      dispatch: actionOrActions => this._dispatcher.dispatch(actionOrActions)\n    };\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      return this._config.developmentMode ? ensureStateAndActionsAreImmutable(rootStateOperations) : rootStateOperations;\n    } else {\n      return rootStateOperations;\n    }\n  }\n  setStateToTheCurrentWithNew(results) {\n    const stateOperations = this.getRootStateOperations();\n    // Get our current stream\n    const currentState = stateOperations.getState();\n    // Set the state to the current + new\n    stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));\n  }\n}\n/** @nocollapse */\nInternalStateOperations.ɵfac = function InternalStateOperations_Factory(t) {\n  return new (t || InternalStateOperations)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalDispatcher), i0.ɵɵinject(NgxsConfig));\n};\n/** @nocollapse */\nInternalStateOperations.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalStateOperations,\n  factory: InternalStateOperations.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalStateOperations, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StateStream\n    }, {\n      type: InternalDispatcher\n    }, {\n      type: NgxsConfig\n    }];\n  }, null);\n})();\nfunction ensureStateAndActionsAreImmutable(root) {\n  return {\n    getState: () => root.getState(),\n    setState: value => {\n      const frozenValue = deepFreeze(value);\n      return root.setState(frozenValue);\n    },\n    dispatch: actions => {\n      return root.dispatch(actions);\n    }\n  };\n}\nfunction simplePatch(value) {\n  return existingState => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (Array.isArray(value)) {\n        throwPatchingArrayError();\n      } else if (typeof value !== 'object') {\n        throwPatchingPrimitiveError();\n      }\n    }\n    const newState = Object.assign({}, existingState);\n    for (const key in value) {\n      // deep clone for patch compatibility\n      newState[key] = value[key];\n    }\n    return newState;\n  };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n  constructor(_internalStateOperations) {\n    this._internalStateOperations = _internalStateOperations;\n  }\n  /**\n   * Create the state context\n   */\n  createStateContext(mappedStore) {\n    const root = this._internalStateOperations.getRootStateOperations();\n    function getState(currentAppState) {\n      return getValue(currentAppState, mappedStore.path);\n    }\n    function setStateValue(currentAppState, newValue) {\n      const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n      root.setState(newAppState);\n      return newAppState;\n      // In doing this refactoring I noticed that there is a 'bug' where the\n      // application state is returned instead of this state slice.\n      // This has worked this way since the beginning see:\n      // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n      // This needs to be fixed, but is a 'breaking' change.\n      // I will do this fix in a subsequent PR and we can decide how to handle it.\n    }\n\n    function setStateFromOperator(currentAppState, stateOperator) {\n      const local = getState(currentAppState);\n      const newValue = stateOperator(local);\n      return setStateValue(currentAppState, newValue);\n    }\n    function isStateOperator(value) {\n      return typeof value === 'function';\n    }\n    return {\n      getState() {\n        const currentAppState = root.getState();\n        return getState(currentAppState);\n      },\n      patchState(val) {\n        const currentAppState = root.getState();\n        const patchOperator = simplePatch(val);\n        return setStateFromOperator(currentAppState, patchOperator);\n      },\n      setState(val) {\n        const currentAppState = root.getState();\n        return isStateOperator(val) ? setStateFromOperator(currentAppState, val) : setStateValue(currentAppState, val);\n      },\n      dispatch(actions) {\n        return root.dispatch(actions);\n      }\n    };\n  }\n}\n/** @nocollapse */\nStateContextFactory.ɵfac = function StateContextFactory_Factory(t) {\n  return new (t || StateContextFactory)(i0.ɵɵinject(InternalStateOperations));\n};\n/** @nocollapse */\nStateContextFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateContextFactory,\n  factory: StateContextFactory.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateContextFactory, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: InternalStateOperations\n    }];\n  }, null);\n})();\nclass StoreValidators {\n  static checkThatStateIsNamedCorrectly(name) {\n    if (!name) {\n      throwStateNamePropertyError();\n    } else if (!this.stateNameRegex.test(name)) {\n      throwStateNameError(name);\n    }\n  }\n  static checkThatStateNameIsUnique(stateName, state, statesByName) {\n    const existingState = statesByName[stateName];\n    if (existingState && existingState !== state) {\n      throwStateUniqueError(stateName, state.name, existingState.name);\n    }\n  }\n  static checkThatStateClassesHaveBeenDecorated(stateClasses) {\n    stateClasses.forEach(stateClass => {\n      if (!getStoreMetadata$1(stateClass)) {\n        throwStateDecoratorError(stateClass.name);\n      }\n    });\n  }\n}\nStoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n  // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  const ngInjectableDef = stateClass.ɵprov;\n  if (!ngInjectableDef) {\n    // Don't warn if Ivy is disabled or `ɵprov` exists on the class\n    console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n  }\n}\n\n/**\n * Init action\n */\nclass InitState {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@INIT';\n  }\n}\n/**\n * Update action\n */\nclass UpdateState {\n  constructor(addedStates) {\n    this.addedStates = addedStates;\n  }\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@UPDATE_STATE';\n  }\n}\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {\n  providedIn: 'root',\n  factory: () => ({\n    warnOnUnhandledActions: true\n  })\n});\nclass NgxsUnhandledActionsLogger {\n  constructor(options) {\n    /**\n     * These actions should be ignored by default; the user can increase this\n     * list in the future via the `ignoreActions` method.\n     */\n    this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n    if (typeof options.warnOnUnhandledActions === 'object') {\n      this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n    }\n  }\n  /**\n   * Adds actions to the internal list of actions that should be ignored.\n   */\n  ignoreActions(...actions) {\n    for (const action of actions) {\n      this._ignoredActions.add(action.type);\n    }\n  }\n  /** @internal */\n  warn(action) {\n    const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n    if (actionShouldBeIgnored) {\n      return;\n    }\n    action = action.constructor && action.constructor.name !== 'Object' ? action.constructor.name : action.type;\n    console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n  }\n}\n/** @nocollapse */\nNgxsUnhandledActionsLogger.ɵfac = function NgxsUnhandledActionsLogger_Factory(t) {\n  return new (t || NgxsUnhandledActionsLogger)(i0.ɵɵinject(NGXS_DEVELOPMENT_OPTIONS));\n};\n/** @nocollapse */\nNgxsUnhandledActionsLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsUnhandledActionsLogger,\n  factory: NgxsUnhandledActionsLogger.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsUnhandledActionsLogger, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_DEVELOPMENT_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * State factory class\n * @ignore\n */\nclass StateFactory {\n  constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n    this._injector = _injector;\n    this._config = _config;\n    this._parentFactory = _parentFactory;\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._stateContextFactory = _stateContextFactory;\n    this._initialState = _initialState;\n    this._actionsSubscription = null;\n    this._states = [];\n    this._statesByName = {};\n    this._statePaths = {};\n    this.getRuntimeSelectorContext = memoize(() => {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const stateFactory = this;\n      function resolveGetter(key) {\n        const path = stateFactory.statePaths[key];\n        return path ? propGetter(path.split('.'), stateFactory._config) : null;\n      }\n      const context = this._parentFactory ? this._parentFactory.getRuntimeSelectorContext() : {\n        getStateGetter(key) {\n          let getter = resolveGetter(key);\n          if (getter) {\n            return getter;\n          }\n          return (...args) => {\n            // Late loaded getter\n            if (!getter) {\n              getter = resolveGetter(key);\n            }\n            return getter ? getter(...args) : undefined;\n          };\n        },\n        getSelectorOptions(localOptions) {\n          const globalSelectorOptions = stateFactory._config.selectorOptions;\n          return Object.assign(Object.assign({}, globalSelectorOptions), localOptions || {});\n        }\n      };\n      return context;\n    });\n  }\n  get states() {\n    return this._parentFactory ? this._parentFactory.states : this._states;\n  }\n  get statesByName() {\n    return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n  }\n  get statePaths() {\n    return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n  }\n  static cloneDefaults(defaults) {\n    let value = {};\n    if (Array.isArray(defaults)) {\n      value = defaults.slice();\n    } else if (isObject$1(defaults)) {\n      value = Object.assign({}, defaults);\n    } else if (defaults === undefined) {\n      value = {};\n    } else {\n      value = defaults;\n    }\n    return value;\n  }\n  ngOnDestroy() {\n    // This is being non-null asserted since `_actionsSubscrition` is\n    // initialized within the constructor.\n    this._actionsSubscription.unsubscribe();\n  }\n  /**\n   * Add a new state to the global defs.\n   */\n  add(stateClasses) {\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);\n    }\n    const {\n      newStates\n    } = this.addToStatesMap(stateClasses);\n    if (!newStates.length) return [];\n    const stateGraph = buildGraph(newStates);\n    const sortedStates = topologicalSort(stateGraph);\n    const paths = findFullParentPath(stateGraph);\n    const nameGraph = nameToState(newStates);\n    const bootstrappedStores = [];\n    for (const name of sortedStates) {\n      const stateClass = nameGraph[name];\n      const path = paths[name];\n      const meta = stateClass[META_KEY];\n      this.addRuntimeInfoToMeta(meta, path);\n      // Note: previously we called `ensureStateClassIsInjectable` within the\n      // `State` decorator. This check is moved here because the `ɵprov` property\n      // will not exist on the class in JIT mode (because it's set asynchronously\n      // during JIT compilation through `Object.defineProperty`).\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        ensureStateClassIsInjectable(stateClass);\n      }\n      const stateMap = {\n        name,\n        path,\n        isInitialised: false,\n        actions: meta.actions,\n        instance: this._injector.get(stateClass),\n        defaults: StateFactory.cloneDefaults(meta.defaults)\n      };\n      // ensure our store hasn't already been added\n      // but don't throw since it could be lazy\n      // loaded from different paths\n      if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n        bootstrappedStores.push(stateMap);\n      }\n      this.states.push(stateMap);\n    }\n    return bootstrappedStores;\n  }\n  /**\n   * Add a set of states to the store and return the defaults\n   */\n  addAndReturnDefaults(stateClasses) {\n    const classes = stateClasses || [];\n    const mappedStores = this.add(classes);\n    const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n    return {\n      defaults,\n      states: mappedStores\n    };\n  }\n  /**\n   * Bind the actions to the handlers\n   */\n  connectActionHandlers() {\n    if (this._actionsSubscription !== null) return;\n    const dispatched$ = new Subject();\n    this._actionsSubscription = this._actions.pipe(filter(ctx => ctx.status === \"DISPATCHED\" /* Dispatched */), mergeMap(ctx => {\n      dispatched$.next(ctx);\n      const action = ctx.action;\n      return this.invokeActions(dispatched$, action).pipe(map(() => ({\n        action,\n        status: \"SUCCESSFUL\" /* Successful */\n      })), defaultIfEmpty({\n        action,\n        status: \"CANCELED\" /* Canceled */\n      }), catchError(error => of({\n        action,\n        status: \"ERRORED\" /* Errored */,\n        error\n      })));\n    })).subscribe(ctx => this._actionResults.next(ctx));\n  }\n  /**\n   * Invoke actions on the states.\n   */\n  invokeActions(dispatched$, action) {\n    const type = getActionTypeFromInstance(action);\n    const results = [];\n    // Determines whether the dispatched action has been handled, this is assigned\n    // to `true` within the below `for` loop if any `actionMetas` has been found.\n    let actionHasBeenHandled = false;\n    for (const metadata of this.states) {\n      const actionMetas = metadata.actions[type];\n      if (actionMetas) {\n        for (const actionMeta of actionMetas) {\n          const stateContext = this._stateContextFactory.createStateContext(metadata);\n          try {\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\n            if (result instanceof Promise) {\n              result = from(result);\n            }\n            if (isObservable(result)) {\n              // If this observable has been completed w/o emitting\n              // any value then we wouldn't want to complete the whole chain\n              // of actions. Since if any observable completes then\n              // action will be canceled.\n              // For instance if any action handler would've had such statement:\n              // `handler(ctx) { return EMPTY; }`\n              // then the action will be canceled.\n              // See https://github.com/ngxs/store/issues/1568\n              result = result.pipe(mergeMap(value => {\n                if (value instanceof Promise) {\n                  return from(value);\n                }\n                if (isObservable(value)) {\n                  return value;\n                }\n                return of(value);\n              }), defaultIfEmpty({}));\n              if (actionMeta.options.cancelUncompleted) {\n                // todo: ofActionDispatched should be used with action class\n                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n              }\n            } else {\n              result = of({}).pipe(shareReplay());\n            }\n            results.push(result);\n          } catch (e) {\n            results.push(throwError(e));\n          }\n          actionHasBeenHandled = true;\n        }\n      }\n    }\n    // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n    // only during development.\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !actionHasBeenHandled) {\n      const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n      // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n      // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n      // didn't return `null` so we may ensure the module has been imported.\n      if (unhandledActionsLogger) {\n        unhandledActionsLogger.warn(action);\n      }\n    }\n    if (!results.length) {\n      results.push(of({}));\n    }\n    return forkJoin(results);\n  }\n  addToStatesMap(stateClasses) {\n    const newStates = [];\n    const statesMap = this.statesByName;\n    for (const stateClass of stateClasses) {\n      const stateName = getStoreMetadata$1(stateClass).name;\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);\n      }\n      const unmountedState = !statesMap[stateName];\n      if (unmountedState) {\n        newStates.push(stateClass);\n        statesMap[stateName] = stateClass;\n      }\n    }\n    return {\n      newStates\n    };\n  }\n  addRuntimeInfoToMeta(meta, path) {\n    this.statePaths[meta.name] = path;\n    // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n    // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n    // We will need to come up with an alternative in v4 because this is used by many plugins\n    meta.path = path;\n  }\n  /**\n   * @description\n   * the method checks if the state has already been added to the tree\n   * and completed the life cycle\n   * @param name\n   * @param path\n   */\n  hasBeenMountedAndBootstrapped(name, path) {\n    const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n    return this.statesByName[name] && valueIsBootstrappedInInitialState;\n  }\n}\n/** @nocollapse */\nStateFactory.ɵfac = function StateFactory_Factory(t) {\n  return new (t || StateFactory)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(StateFactory, 12), i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\nStateFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateFactory,\n  factory: StateFactory.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateFactory, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }, {\n      type: NgxsConfig\n    }, {\n      type: StateFactory,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: InternalActions\n    }, {\n      type: InternalDispatchedActionResults\n    }, {\n      type: StateContextFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n  getOptions: target => {\n    return target && target[SELECTOR_OPTIONS_META_KEY] || {};\n  },\n  defineOptions: (target, options) => {\n    if (!target) return;\n    target[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\n/**\n * Function for creating a selector\n * @param selectors The selectors to use to create the arguments of this function\n * @param originalFn The original function being made into a selector\n * @param creationMetadata\n */\nfunction createSelector(selectors, originalFn, creationMetadata) {\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n  const wrappedFn = function wrappedSelectorFn(...args) {\n    const returnValue = originalFn.apply(containerClass, args);\n    if (returnValue instanceof Function) {\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n    return returnValue;\n  };\n  const memoizedFn = memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n  const selectorMetaData = setupSelectorMetadata(originalFn, creationMetadata);\n  const makeRootSelector = context => {\n    const {\n      argumentSelectorFunctions,\n      selectorOptions\n    } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n    return function selectFromRoot(rootState) {\n      // Determine arguments from the app state using the selectors\n      const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n      // if the lambda tries to access a something on the\n      // state that doesn't exist, it will throw a TypeError.\n      // since this is quite usual behaviour, we simply return undefined if so.\n      try {\n        return memoizedFn(...results);\n      } catch (ex) {\n        if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n          return undefined;\n        }\n        throw ex;\n      }\n    };\n  };\n  selectorMetaData.makeRootSelector = makeRootSelector;\n  return memoizedFn;\n}\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n  const selectorMetaData = ensureSelectorMetadata$1(originalFn);\n  selectorMetaData.originalFn = originalFn;\n  let getExplicitSelectorOptions = () => ({});\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName;\n    getExplicitSelectorOptions = creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n  const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n  selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n  return selectorMetaData;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n  const argumentSelectorFunctions = selectorsToApply.map(selector => {\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}), selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}), selectorMetaData.getSelectorOptions() || {}), explicitOptions);\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n  const selectorsToApply = [];\n  const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n    const metadata = getStoreMetadata$1(containerClass);\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n  if (selectors) {\n    selectorsToApply.push(...selectors);\n  }\n  return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n  return metadata && metadata.makeRootSelector || (() => selector);\n}\n\n// tslint:disable:unified-signatures\nclass Store {\n  constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n    this._stateStream = _stateStream;\n    this._internalStateOperations = _internalStateOperations;\n    this._config = _config;\n    this._internalExecutionStrategy = _internalExecutionStrategy;\n    this._stateFactory = _stateFactory;\n    /**\n     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n     */\n    this._selectableStateStream = this._stateStream.pipe(observeOn(queueScheduler), leaveNgxs(this._internalExecutionStrategy), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n    this.initStateStream(initialStateValue);\n  }\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n  }\n  select(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return this._selectableStateStream.pipe(map(selectorFn), catchError(err => {\n      // if error is TypeError we swallow it to prevent usual errors with property access\n      const {\n        suppressErrors\n      } = this._config.selectorOptions;\n      if (err instanceof TypeError && suppressErrors) {\n        return of(undefined);\n      }\n      // rethrow other errors\n      return throwError(err);\n    }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n  }\n  selectOnce(selector) {\n    return this.select(selector).pipe(take(1));\n  }\n  selectSnapshot(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return selectorFn(this._stateStream.getValue());\n  }\n  /**\n   * Allow the user to subscribe to the root of the state\n   */\n  subscribe(fn) {\n    return this._selectableStateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n  }\n  /**\n   * Return the raw value of the state.\n   */\n  snapshot() {\n    return this._internalStateOperations.getRootStateOperations().getState();\n  }\n  /**\n   * Reset the state to a specific point in time. This method is useful\n   * for plugin's who need to modify the state directly or unit testing.\n   */\n  reset(state) {\n    return this._internalStateOperations.getRootStateOperations().setState(state);\n  }\n  getStoreBoundSelectorFn(selector) {\n    const makeSelectorFn = getRootSelectorFactory(selector);\n    const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n    return makeSelectorFn(runtimeContext);\n  }\n  initStateStream(initialStateValue) {\n    const value = this._stateStream.value;\n    const storeIsEmpty = !value || Object.keys(value).length === 0;\n    if (storeIsEmpty) {\n      const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n      const storeValues = defaultStateNotEmpty ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;\n      this._stateStream.next(storeValues);\n    }\n  }\n}\n/** @nocollapse */\nStore.ɵfac = function Store_Factory(t) {\n  return new (t || Store)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(StateFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\nStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Store,\n  factory: Store.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Store, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StateStream\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: NgxsConfig\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }, {\n      type: StateFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\nclass LifecycleStateManager {\n  constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {\n    this._store = _store;\n    this._internalErrorReporter = _internalErrorReporter;\n    this._internalStateOperations = _internalStateOperations;\n    this._stateContextFactory = _stateContextFactory;\n    this._bootstrapper = _bootstrapper;\n    this._destroy$ = new Subject();\n  }\n  ngOnDestroy() {\n    this._destroy$.next();\n  }\n  ngxsBootstrap(action, results) {\n    this._internalStateOperations.getRootStateOperations().dispatch(action).pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {\n      // The `SafeSubscriber` (which is used by most RxJS operators) re-throws\n      // errors asynchronously (`setTimeout(() => { throw error })`). This might\n      // break existing user's code or unit tests. We catch the error manually to\n      // be backward compatible with the old behavior.\n      this._internalErrorReporter.reportErrorSafely(error);\n      return EMPTY;\n    }), takeUntil(this._destroy$)).subscribe(() => this._invokeBootstrapOnStates(results.states));\n  }\n  _invokeInitOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsOnChanges) {\n        this._store.select(state => getValue(state, mappedStore.path)).pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$)).subscribe(([previousValue, currentValue]) => {\n          const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n          instance.ngxsOnChanges(change);\n        });\n      }\n      if (instance.ngxsOnInit) {\n        instance.ngxsOnInit(this._getStateContext(mappedStore));\n      }\n      mappedStore.isInitialised = true;\n    }\n  }\n  _invokeBootstrapOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsAfterBootstrap) {\n        instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n      }\n    }\n  }\n  _getStateContext(mappedStore) {\n    return this._stateContextFactory.createStateContext(mappedStore);\n  }\n}\n/** @nocollapse */\nLifecycleStateManager.ɵfac = function LifecycleStateManager_Factory(t) {\n  return new (t || LifecycleStateManager)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalErrorReporter), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(i5.NgxsBootstrapper));\n};\n/** @nocollapse */\nLifecycleStateManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LifecycleStateManager,\n  factory: LifecycleStateManager.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LifecycleStateManager, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: InternalErrorReporter\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: StateContextFactory\n    }, {\n      type: i5.NgxsBootstrapper\n    }];\n  }, null);\n})();\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n  constructor(store, config) {\n    SelectFactory.store = store;\n    SelectFactory.config = config;\n  }\n  ngOnDestroy() {\n    SelectFactory.store = null;\n    SelectFactory.config = null;\n  }\n}\nSelectFactory.store = null;\nSelectFactory.config = null;\n/** @nocollapse */\nSelectFactory.ɵfac = function SelectFactory_Factory(t) {\n  return new (t || SelectFactory)(i0.ɵɵinject(Store), i0.ɵɵinject(NgxsConfig));\n};\n/** @nocollapse */\nSelectFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SelectFactory,\n  factory: SelectFactory.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SelectFactory, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: NgxsConfig\n    }];\n  }, null);\n})();\n\n/**\n * Root module\n * @ignore\n */\nclass NgxsRootModule {\n  constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n    // Add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(states);\n    internalStateOperations.setStateToTheCurrentWithNew(results);\n    // Connect our actions stream\n    factory.connectActionHandlers();\n    // Dispatch the init action and invoke init and bootstrap functions after\n    lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n  }\n}\n/** @nocollapse */\nNgxsRootModule.ɵfac = function NgxsRootModule_Factory(t) {\n  return new (t || NgxsRootModule)(i0.ɵɵinject(StateFactory), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(Store), i0.ɵɵinject(SelectFactory), i0.ɵɵinject(ROOT_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n};\n/** @nocollapse */\nNgxsRootModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsRootModule\n});\n/** @nocollapse */\nNgxsRootModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsRootModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: StateFactory\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: Store\n    }, {\n      type: SelectFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [ROOT_STATE_TOKEN]\n      }]\n    }, {\n      type: LifecycleStateManager\n    }];\n  }, null);\n})();\n\n/**\n * Feature module\n * @ignore\n */\nclass NgxsFeatureModule {\n  constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\n    // flatten it [[Feature1State, Feature2State], [Feature3State]]\n    const flattenedStates = NgxsFeatureModule.flattenStates(states);\n    // add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(flattenedStates);\n    if (results.states.length) {\n      internalStateOperations.setStateToTheCurrentWithNew(results);\n      // dispatch the update action and invoke init and bootstrap functions after\n      lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n    }\n  }\n  static flattenStates(states = []) {\n    return states.reduce((total, values) => total.concat(values), []);\n  }\n}\n/** @nocollapse */\nNgxsFeatureModule.ɵfac = function NgxsFeatureModule_Factory(t) {\n  return new (t || NgxsFeatureModule)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateFactory), i0.ɵɵinject(FEATURE_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n};\n/** @nocollapse */\nNgxsFeatureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsFeatureModule\n});\n/** @nocollapse */\nNgxsFeatureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsFeatureModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: StateFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FEATURE_STATE_TOKEN]\n      }]\n    }, {\n      type: LifecycleStateManager\n    }];\n  }, null);\n})();\n\n/**\n * Ngxs Module\n */\nclass NgxsModule {\n  /**\n   * Root module factory\n   */\n  static forRoot(states = [], options = {}) {\n    return {\n      ngModule: NgxsRootModule,\n      providers: [StateFactory, StateContextFactory, Actions, InternalActions, NgxsBootstrapper, LifecycleStateManager, InternalDispatcher, InternalDispatchedActionResults, InternalStateOperations, InternalNgxsExecutionStrategy, Store, StateStream, SelectFactory, PluginManager, ...states, ...NgxsModule.ngxsTokenProviders(states, options)]\n    };\n  }\n  /**\n   * Feature module factory\n   */\n  static forFeature(states = []) {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: [StateFactory, PluginManager, ...states, {\n        provide: FEATURE_STATE_TOKEN,\n        multi: true,\n        useValue: states\n      }]\n    };\n  }\n  static ngxsTokenProviders(states, options) {\n    return [{\n      provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n      useValue: options.executionStrategy\n    }, {\n      provide: ROOT_STATE_TOKEN,\n      useValue: states\n    }, {\n      provide: NgxsModule.ROOT_OPTIONS,\n      useValue: options\n    }, {\n      provide: NgxsConfig,\n      useFactory: NgxsModule.ngxsConfigFactory,\n      deps: [NgxsModule.ROOT_OPTIONS]\n    }, {\n      provide: APP_BOOTSTRAP_LISTENER,\n      useFactory: NgxsModule.appBootstrapListenerFactory,\n      multi: true,\n      deps: [NgxsBootstrapper]\n    }, {\n      provide: INITIAL_STATE_TOKEN,\n      useFactory: NgxsModule.getInitialState\n    }, {\n      provide: ɵNGXS_STATE_CONTEXT_FACTORY,\n      useExisting: StateContextFactory\n    }, {\n      provide: ɵNGXS_STATE_FACTORY,\n      useExisting: StateFactory\n    }];\n  }\n  static ngxsConfigFactory(options) {\n    return mergeDeep(new NgxsConfig(), options);\n  }\n  static appBootstrapListenerFactory(bootstrapper) {\n    return () => bootstrapper.bootstrap();\n  }\n  static getInitialState() {\n    return InitialState.pop();\n  }\n}\nNgxsModule.ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\n/** @nocollapse */\nNgxsModule.ɵfac = function NgxsModule_Factory(t) {\n  return new (t || NgxsModule)();\n};\n/** @nocollapse */\nNgxsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsModule\n});\n/** @nocollapse */\nNgxsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n/**\n * Decorates a method with a action information.\n */\nfunction Action(actions, options) {\n  return (target, name) => {\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const isStaticMethod = target.hasOwnProperty('prototype');\n      if (isStaticMethod) {\n        throwActionDecoratorError();\n      }\n    }\n    const meta = ensureStoreMetadata$1(target.constructor);\n    if (!Array.isArray(actions)) {\n      actions = [actions];\n    }\n    for (const action of actions) {\n      const type = action.type;\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n  function getStateOptions(inheritedStateClass) {\n    const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n    return Object.assign(Object.assign({}, inheritanceOptions), options);\n  }\n  function mutateMetaData(params) {\n    const {\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    } = params;\n    const {\n      children,\n      defaults,\n      name\n    } = optionsWithInheritance;\n    const stateName = typeof name === 'string' ? name : name && name.getName() || null;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      StoreValidators.checkThatStateIsNamedCorrectly(stateName);\n    }\n    if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n      const inheritedMeta = inheritedStateClass[META_KEY] || {};\n      meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);\n    }\n    meta.children = children;\n    meta.defaults = defaults;\n    meta.name = stateName;\n  }\n  return target => {\n    const stateClass = target;\n    const meta = ensureStoreMetadata$1(stateClass);\n    const inheritedStateClass = Object.getPrototypeOf(stateClass);\n    const optionsWithInheritance = getStateOptions(inheritedStateClass);\n    mutateMetaData({\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    });\n    stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n  };\n}\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n  if (!SelectFactory.store) {\n    throwSelectFactoryNotConnectedError();\n  }\n  return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n  if (typeof rawSelector === 'string') {\n    const propsArray = paths.length ? [rawSelector, ...paths] : rawSelector.split('.');\n    return propGetter(propsArray, SelectFactory.config);\n  }\n  return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n  const lastCharIndex = name.length - 1;\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nfunction Select(rawSelector, ...paths) {\n  return function (target, key) {\n    const name = key.toString();\n    const selectorId = `__${name}__selector`;\n    const selector = createSelectorFn(name, rawSelector, paths);\n    Object.defineProperties(target, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      [name]: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n        }\n      }\n    });\n  };\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n  return function decorate(target, methodName, descriptor) {\n    if (methodName) {\n      descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName));\n      // Method Decorator\n      const originalFn = descriptor.value || descriptor.originalFn;\n      if (originalFn) {\n        selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n      }\n    } else {\n      // Class Decorator\n      selectorOptionsMetaAccessor.defineOptions(target, options);\n    }\n  };\n}\nfunction ensureStoreMetadata(target) {\n  return ensureStoreMetadata$1(target);\n}\nfunction getStoreMetadata(target) {\n  return getStoreMetadata$1(target);\n}\nfunction ensureSelectorMetadata(target) {\n  return ensureSelectorMetadata$1(target);\n}\nfunction getSelectorMetadata(target) {\n  return getSelectorMetadata$1(target);\n}\n\n/**\n * Decorator for memoizing a state selector.\n */\nfunction Selector(selectors) {\n  return (target, key, descriptor) => {\n    descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));\n    const originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (originalFn && typeof originalFn !== 'function') {\n        throwSelectorDecoratorError();\n      }\n    }\n    const memoizedFn = createSelector(selectors, originalFn, {\n      containerClass: target,\n      selectorName: key.toString(),\n      getSelectorOptions() {\n        return {};\n      }\n    });\n    const newDescriptor = {\n      configurable: true,\n      get() {\n        return memoizedFn;\n      }\n    };\n    // Add hidden property to descriptor\n    newDescriptor['originalFn'] = originalFn;\n    return newDescriptor;\n  };\n}\nclass StateToken {\n  constructor(name) {\n    this.name = name;\n    const selectorMetadata = ensureSelectorMetadata$1(this);\n    selectorMetadata.makeRootSelector = runtimeContext => {\n      return runtimeContext.getStateGetter(this.name);\n    };\n  }\n  getName() {\n    return this.name;\n  }\n  toString() {\n    return `StateToken[${this.name}]`;\n  }\n}\nclass NgxsDevelopmentModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsDevelopmentModule,\n      providers: [NgxsUnhandledActionsLogger, {\n        provide: NGXS_DEVELOPMENT_OPTIONS,\n        useValue: options\n      }]\n    };\n  }\n}\n/** @nocollapse */\nNgxsDevelopmentModule.ɵfac = function NgxsDevelopmentModule_Factory(t) {\n  return new (t || NgxsDevelopmentModule)();\n};\n/** @nocollapse */\nNgxsDevelopmentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsDevelopmentModule\n});\n/** @nocollapse */\nNgxsDevelopmentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsDevelopmentModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createSelector, ensureSelectorMetadata, ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata, getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule };","map":{"version":3,"names":["i0","NgZone","PLATFORM_ID","Injectable","Inject","InjectionToken","inject","INJECTOR","ɵglobal","ErrorHandler","Optional","SkipSelf","NgModule","APP_BOOTSTRAP_LISTENER","i5","memoize","INITIAL_STATE_TOKEN","NgxsBootstrapper","ɵNGXS_STATE_CONTEXT_FACTORY","ɵNGXS_STATE_FACTORY","InitialState","isPlatformServer","Observable","Subject","BehaviorSubject","of","forkJoin","throwError","EMPTY","from","isObservable","queueScheduler","filter","map","share","shareReplay","take","exhaustMap","mergeMap","defaultIfEmpty","catchError","takeUntil","observeOn","distinctUntilChanged","tap","startWith","pairwise","throwStateNameError","name","Error","throwStateNamePropertyError","throwStateUniqueError","current","newName","oldName","throwStateDecoratorError","throwActionDecoratorError","throwSelectorDecoratorError","getZoneWarningMessage","getUndecoratedStateInIvyWarningMessage","throwSelectFactoryNotConnectedError","throwPatchingArrayError","throwPatchingPrimitiveError","DispatchOutsideZoneNgxsExecutionStrategy","constructor","_ngZone","_platformId","ngDevMode","verifyZoneIsNotNooped","enter","func","runInsideAngular","runOutsideAngular","leave","isInAngularZone","run","ɵfac","ɵprov","type","args","providedIn","undefined","decorators","ngZone","console","warn","ROOT_STATE_TOKEN","FEATURE_STATE_TOKEN","NGXS_PLUGINS","META_KEY","META_OPTIONS_KEY","SELECTOR_META_KEY","NgxsConfig","defaultsState","selectorOptions","injectContainerState","suppressErrors","compatibility","strictContentSecurityPolicy","executionStrategy","NgxsSimpleChange","previousValue","currentValue","firstChange","NoopNgxsExecutionStrategy","USER_PROVIDED_NGXS_EXECUTION_STRATEGY","NGXS_EXECUTION_STRATEGY","factory","injector","get","Zone","ensureStoreMetadata$1","target","hasOwnProperty","defaultMetadata","actions","defaults","path","makeRootSelector","context","getStateGetter","children","Object","defineProperty","value","getStoreMetadata$1","ensureSelectorMetadata$1","originalFn","containerClass","selectorName","getSelectorOptions","getSelectorMetadata$1","compliantPropGetter","paths","copyOfPaths","slice","obj","reduce","acc","part","fastPropGetter","segments","seg","i","l","length","expr","fn","Function","propGetter","config","buildGraph","stateClasses","findName","stateClass","meta","find","g","result","nameToState","states","findFullParentPath","newObj","visit","child","keyToFind","key","indexOf","parent","topologicalSort","graph","sorted","visited","ancestors","Array","isArray","push","forEach","dep","join","keys","k","reverse","isObject$1","getActionTypeFromInstance","action","actionMatcher","action1","type1","action2","setValue","prop","val","assign","split","lastIndex","index","getValue","isObject","item","mergeDeep","base","sources","source","shift","ofAction","allowedTypes","ofActionOperator","ofActionDispatched","ofActionSuccessful","ofActionCanceled","ofActionCompleted","allowedStatuses","mapActionResult","ofActionErrored","statuses","mapOperator","mapAction","allowedMap","createAllowedActionTypesMap","allowedStatusMap","createAllowedStatusesMap","o","pipe","filterStatus","ctx","actionType","typeMatch","statusMatch","status","error","successful","canceled","types","filterMap","klass","leaveNgxs","ngxsExecutionStrategy","sink","subscribe","next","complete","InternalNgxsExecutionStrategy","_executionStrategy","OrderedSubject","arguments","_itemQueue","_busyPushingNext","unshift","nextValue","pop","InternalActions","ngOnDestroy","Actions","internalActions$","internalExecutionStrategy","sharedInternalActions$","observer","childSubscription","add","compose","funcs","curr","nextArgs","ngxsErrorHandler","internalErrorReporter","subscribed","Promise","resolve","then","reportErrorSafely","subscriber","InternalErrorReporter","_injector","_errorHandler","handleError","_a","Injector","StateStream","PluginManager","_parentManager","_pluginHandlers","plugins","registerHandlers","rootPlugins","pluginHandlers","getPluginHandlers","handlers","plugin","handle","bind","InternalDispatchedActionResults","InternalDispatcher","_actions","_actionResults","_pluginManager","_stateStream","_ngxsExecutionStrategy","_internalErrorReporter","dispatch","actionOrActions","dispatchByEvents","dispatchSingle","prevState","nextState","nextAction","actionResult$","getActionResultStream","createDispatchObservable","deepFreeze","freeze","oIsFunction","hasOwnProp","prototype","getOwnPropertyNames","call","isFrozen","InternalStateOperations","_dispatcher","_config","getRootStateOperations","rootStateOperations","getState","setState","newState","developmentMode","ensureStateAndActionsAreImmutable","setStateToTheCurrentWithNew","results","stateOperations","currentState","root","frozenValue","simplePatch","existingState","StateContextFactory","_internalStateOperations","createStateContext","mappedStore","currentAppState","setStateValue","newValue","newAppState","setStateFromOperator","stateOperator","local","isStateOperator","patchState","patchOperator","StoreValidators","checkThatStateIsNamedCorrectly","stateNameRegex","test","checkThatStateNameIsUnique","stateName","state","statesByName","checkThatStateClassesHaveBeenDecorated","RegExp","ensureStateClassIsInjectable","ngInjectableDef","InitState","UpdateState","addedStates","NGXS_DEVELOPMENT_OPTIONS","warnOnUnhandledActions","NgxsUnhandledActionsLogger","options","_ignoredActions","Set","ignoreActions","ignore","actionShouldBeIgnored","some","StateFactory","_parentFactory","_stateContextFactory","_initialState","_actionsSubscription","_states","_statesByName","_statePaths","getRuntimeSelectorContext","stateFactory","resolveGetter","statePaths","getter","localOptions","globalSelectorOptions","cloneDefaults","unsubscribe","newStates","addToStatesMap","stateGraph","sortedStates","nameGraph","bootstrappedStores","addRuntimeInfoToMeta","stateMap","isInitialised","instance","hasBeenMountedAndBootstrapped","addAndReturnDefaults","classes","mappedStores","connectActionHandlers","dispatched$","invokeActions","actionHasBeenHandled","metadata","actionMetas","actionMeta","stateContext","cancelUncompleted","e","unhandledActionsLogger","statesMap","unmountedState","valueIsBootstrappedInInitialState","SELECTOR_OPTIONS_META_KEY","selectorOptionsMetaAccessor","getOptions","defineOptions","createSelector","selectors","creationMetadata","wrappedFn","wrappedSelectorFn","returnValue","apply","innerMemoizedFn","memoizedFn","setPrototypeOf","selectorMetaData","setupSelectorMetadata","argumentSelectorFunctions","getRuntimeSelectorInfo","selectFromRoot","rootState","argFn","ex","TypeError","getExplicitSelectorOptions","selectorMetaDataClone","getLocalSelectorOptions","localSelectorOptions","selectorsToApply","getSelectorsToApply","selector","getRootSelectorFactory","explicitOptions","canInjectContainerState","Store","_internalExecutionStrategy","_stateFactory","initialStateValue","_selectableStateStream","bufferSize","refCount","initStateStream","select","selectorFn","getStoreBoundSelectorFn","err","selectOnce","selectSnapshot","snapshot","reset","makeSelectorFn","runtimeContext","storeIsEmpty","defaultStateNotEmpty","storeValues","LifecycleStateManager","_store","_bootstrapper","_destroy$","ngxsBootstrap","_invokeInitOnStates","appBootstrapped$","appBootstrapped","_invokeBootstrapOnStates","ngxsOnChanges","change","ngxsOnInit","_getStateContext","ngxsAfterBootstrap","SelectFactory","store","NgxsRootModule","internalStateOperations","_select","lifecycleStateManager","ɵmod","ɵinj","NgxsFeatureModule","flattenedStates","flattenStates","total","values","concat","NgxsModule","forRoot","ngModule","providers","ngxsTokenProviders","forFeature","provide","multi","useValue","ROOT_OPTIONS","useFactory","ngxsConfigFactory","deps","appBootstrapListenerFactory","getInitialState","useExisting","bootstrapper","bootstrap","Action","isStaticMethod","State","getStateOptions","inheritedStateClass","inheritanceOptions","mutateMetaData","params","optionsWithInheritance","getName","inheritedMeta","getPrototypeOf","DOLLAR_CHAR_CODE","createSelectObservable","createSelectorFn","rawSelector","removeDollarAtTheEnd","propsArray","lastCharIndex","dollarAtTheEnd","charCodeAt","Select","toString","selectorId","defineProperties","writable","enumerable","configurable","SelectorOptions","decorate","methodName","descriptor","getOwnPropertyDescriptor","ensureStoreMetadata","getStoreMetadata","ensureSelectorMetadata","getSelectorMetadata","Selector","newDescriptor","StateToken","selectorMetadata","NgxsDevelopmentModule","ɵNgxsFeatureModule","ɵNgxsRootModule"],"sources":["/Users/ryhor_yakaukin/Downloads/projects/angular_test/node_modules/@ngxs/store/fesm2015/ngxs-store.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, inject, INJECTOR, ɵglobal, ErrorHandler, Optional, SkipSelf, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport * as i5 from '@ngxs/store/internals';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY, InitialState } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, isObservable, queueScheduler } from 'rxjs';\nimport { filter, map, share, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, observeOn, distinctUntilChanged, tap, startWith, pairwise } from 'rxjs/operators';\n\nfunction throwStateNameError(name) {\n    throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n    throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n    throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n    throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n    throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n    throw new Error('Selectors only work on methods.');\n}\nfunction getZoneWarningMessage() {\n    return ('Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' +\n        'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' +\n        'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })');\n}\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n    return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction throwSelectFactoryNotConnectedError() {\n    throw new Error('You have forgotten to import the NGXS module!');\n}\nfunction throwPatchingArrayError() {\n    throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n    throw new Error('Patching primitives is not supported.');\n}\n\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n    constructor(_ngZone, _platformId) {\n        this._ngZone = _ngZone;\n        this._platformId = _platformId;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            verifyZoneIsNotNooped(_ngZone);\n        }\n    }\n    enter(func) {\n        if (isPlatformServer(this._platformId)) {\n            return this.runInsideAngular(func);\n        }\n        return this.runOutsideAngular(func);\n    }\n    leave(func) {\n        return this.runInsideAngular(func);\n    }\n    runInsideAngular(func) {\n        if (NgZone.isInAngularZone()) {\n            return func();\n        }\n        return this._ngZone.run(func);\n    }\n    runOutsideAngular(func) {\n        if (NgZone.isInAngularZone()) {\n            return this._ngZone.runOutsideAngular(func);\n        }\n        return func();\n    }\n}\n/** @nocollapse */ DispatchOutsideZoneNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, deps: [{ token: i0.NgZone }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ DispatchOutsideZoneNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; } });\n// Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\nfunction verifyZoneIsNotNooped(ngZone) {\n    // `NoopNgZone` is not exposed publicly as it doesn't expect\n    // to be used outside of the core Angular code, thus we just have\n    // to check if the zone doesn't extend or instanceof `NgZone`.\n    if (ngZone instanceof NgZone) {\n        return;\n    }\n    console.warn(getZoneWarningMessage());\n}\n\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nconst META_KEY = 'NGXS_META';\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n    constructor() {\n        /**\n         * Defining the default state before module initialization\n         * This is convenient if we need to create a define our own set of states.\n         * @deprecated will be removed after v4\n         * (default: {})\n         */\n        this.defaultsState = {};\n        /**\n         * Defining shared selector options\n         */\n        this.selectorOptions = {\n            injectContainerState: true,\n            suppressErrors: true // TODO: default is true in v3, will change in v4\n        };\n        this.compatibility = {\n            strictContentSecurityPolicy: false\n        };\n        this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n    }\n}\n/** @nocollapse */ NgxsConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NgxsConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n    constructor(previousValue, currentValue, firstChange) {\n        this.previousValue = previousValue;\n        this.currentValue = currentValue;\n        this.firstChange = firstChange;\n    }\n}\n\nclass NoopNgxsExecutionStrategy {\n    enter(func) {\n        return func();\n    }\n    leave(func) {\n        return func();\n    }\n}\n/** @nocollapse */ NoopNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NoopNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n */\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n    providedIn: 'root',\n    factory: () => {\n        const injector = inject(INJECTOR);\n        const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n        return executionStrategy\n            ? injector.get(executionStrategy)\n            : injector.get(typeof ɵglobal.Zone !== 'undefined'\n                ? DispatchOutsideZoneNgxsExecutionStrategy\n                : NoopNgxsExecutionStrategy);\n    }\n});\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ensureStoreMetadata$1(target) {\n    if (!target.hasOwnProperty(META_KEY)) {\n        const defaultMetadata = {\n            name: null,\n            actions: {},\n            defaults: {},\n            path: null,\n            makeRootSelector(context) {\n                return context.getStateGetter(defaultMetadata.name);\n            },\n            children: []\n        };\n        Object.defineProperty(target, META_KEY, { value: defaultMetadata });\n    }\n    return getStoreMetadata$1(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction getStoreMetadata$1(target) {\n    return target[META_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ensureSelectorMetadata$1(target) {\n    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n        const defaultMetadata = {\n            makeRootSelector: null,\n            originalFn: null,\n            containerClass: null,\n            selectorName: null,\n            getSelectorOptions: () => ({})\n        };\n        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });\n    }\n    return getSelectorMetadata$1(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction getSelectorMetadata$1(target) {\n    return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n    const copyOfPaths = paths.slice();\n    return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n    const segments = paths;\n    let seg = 'store.' + segments[0];\n    let i = 0;\n    const l = segments.length;\n    let expr = seg;\n    while (++i < l) {\n        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n    }\n    const fn = new Function('store', 'return ' + expr + ';');\n    return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nfunction propGetter(paths, config) {\n    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n        return compliantPropGetter(paths);\n    }\n    else {\n        return fastPropGetter(paths);\n    }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n    const findName = (stateClass) => {\n        const meta = stateClasses.find(g => g === stateClass);\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n            throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n        }\n        return meta[META_KEY].name;\n    };\n    return stateClasses.reduce((result, stateClass) => {\n        const { name, children } = stateClass[META_KEY];\n        result[name] = (children || []).map(findName);\n        return result;\n    }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n    return states.reduce((result, stateClass) => {\n        const meta = stateClass[META_KEY];\n        result[meta.name] = stateClass;\n        return result;\n    }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, newObj = {}) {\n    const visit = (child, keyToFind) => {\n        for (const key in child) {\n            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n                const parent = visit(child, key);\n                return parent !== null ? `${parent}.${key}` : key;\n            }\n        }\n        return null;\n    };\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const parent = visit(obj, key);\n            newObj[key] = parent ? `${parent}.${key}` : key;\n        }\n    }\n    return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n    const sorted = [];\n    const visited = {};\n    const visit = (name, ancestors = []) => {\n        if (!Array.isArray(ancestors)) {\n            ancestors = [];\n        }\n        ancestors.push(name);\n        visited[name] = true;\n        graph[name].forEach((dep) => {\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n            }\n            if (visited[dep]) {\n                return;\n            }\n            visit(dep, ancestors.slice(0));\n        });\n        if (sorted.indexOf(name) < 0) {\n            sorted.push(name);\n        }\n    };\n    Object.keys(graph).forEach(k => visit(k));\n    return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nfunction isObject$1(obj) {\n    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';\n}\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n    if (action.constructor && action.constructor.type) {\n        return action.constructor.type;\n    }\n    else {\n        return action.type;\n    }\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n    const type1 = getActionTypeFromInstance(action1);\n    return function (action2) {\n        return type1 === getActionTypeFromInstance(action2);\n    };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n    obj = Object.assign({}, obj);\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n        }\n        return acc && acc[part];\n    }, obj);\n    return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n */\nconst isObject = (item) => {\n    return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * @param base base object onto which `sources` will be applied\n */\nconst mergeDeep = (base, ...sources) => {\n    if (!sources.length)\n        return base;\n    const source = sources.shift();\n    if (isObject(base) && isObject(source)) {\n        for (const key in source) {\n            if (isObject(source[key])) {\n                if (!base[key])\n                    Object.assign(base, { [key]: {} });\n                mergeDeep(base[key], source[key]);\n            }\n            else {\n                Object.assign(base, { [key]: source[key] });\n            }\n        }\n    }\n    return mergeDeep(base, ...sources);\n};\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n    return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"DISPATCHED\" /* Dispatched */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"SUCCESSFUL\" /* Successful */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"CANCELED\" /* Canceled */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n    const allowedStatuses = [\n        \"SUCCESSFUL\" /* Successful */,\n        \"CANCELED\" /* Canceled */,\n        \"ERRORED\" /* Errored */\n    ];\n    return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"ERRORED\" /* Errored */]);\n}\nfunction ofActionOperator(allowedTypes, statuses, \n// This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n    const allowedMap = createAllowedActionTypesMap(allowedTypes);\n    const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n    return function (o) {\n        return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n    };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n    return filter((ctx) => {\n        const actionType = getActionTypeFromInstance(ctx.action);\n        const typeMatch = allowedTypes[actionType];\n        const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n        return typeMatch && statusMatch;\n    });\n}\nfunction mapActionResult() {\n    return map(({ action, status, error }) => {\n        return {\n            action,\n            result: {\n                successful: \"SUCCESSFUL\" /* Successful */ === status,\n                canceled: \"CANCELED\" /* Canceled */ === status,\n                error\n            }\n        };\n    });\n}\nfunction mapAction() {\n    return map((ctx) => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n    return types.reduce((filterMap, klass) => {\n        filterMap[getActionTypeFromInstance(klass)] = true;\n        return filterMap;\n    }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n    return statuses.reduce((filterMap, status) => {\n        filterMap[status] = true;\n        return filterMap;\n    }, {});\n}\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n    return (source) => {\n        return new Observable((sink) => {\n            return source.subscribe({\n                next(value) {\n                    ngxsExecutionStrategy.leave(() => sink.next(value));\n                },\n                error(error) {\n                    ngxsExecutionStrategy.leave(() => sink.error(error));\n                },\n                complete() {\n                    ngxsExecutionStrategy.leave(() => sink.complete());\n                }\n            });\n        });\n    };\n}\n\nclass InternalNgxsExecutionStrategy {\n    constructor(_executionStrategy) {\n        this._executionStrategy = _executionStrategy;\n    }\n    enter(func) {\n        return this._executionStrategy.enter(func);\n    }\n    leave(func) {\n        return this._executionStrategy.leave(func);\n    }\n}\n/** @nocollapse */ InternalNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy, deps: [{ token: NGXS_EXECUTION_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_EXECUTION_STRATEGY]\n                }] }]; } });\n\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedSubject extends Subject {\n    constructor() {\n        super(...arguments);\n        this._itemQueue = [];\n        this._busyPushingNext = false;\n    }\n    next(value) {\n        if (this._busyPushingNext) {\n            this._itemQueue.unshift(value);\n            return;\n        }\n        this._busyPushingNext = true;\n        super.next(value);\n        while (this._itemQueue.length > 0) {\n            const nextValue = this._itemQueue.pop();\n            super.next(nextValue);\n        }\n        this._busyPushingNext = false;\n    }\n}\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends OrderedSubject {\n    ngOnDestroy() {\n        this.complete();\n    }\n}\n/** @nocollapse */ InternalActions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalActions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions, decorators: [{\n            type: Injectable\n        }] });\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n    constructor(internalActions$, internalExecutionStrategy) {\n        const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy), \n        // The `InternalActions` subject emits outside of the Angular zone.\n        // We have to re-enter the Angular zone for any incoming consumer.\n        // The `share()` operator reduces the number of change detections.\n        // This would call leave only once for any stream emission across all active subscribers.\n        share());\n        super(observer => {\n            const childSubscription = sharedInternalActions$.subscribe({\n                next: ctx => observer.next(ctx),\n                error: error => observer.error(error),\n                complete: () => observer.complete()\n            });\n            observer.add(childSubscription);\n        });\n    }\n}\n/** @nocollapse */ Actions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions, deps: [{ token: InternalActions }, { token: InternalNgxsExecutionStrategy }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ Actions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: InternalActions }, { type: InternalNgxsExecutionStrategy }]; } });\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nconst compose = (funcs) => (...args) => {\n    const curr = funcs.shift();\n    return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\nfunction ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {\n    return (source) => {\n        let subscribed = false;\n        source.subscribe({\n            error: error => {\n                // Do not trigger change detection for a microtask. This depends on the execution\n                // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`\n                // leaves the Angular zone.\n                ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {\n                    if (!subscribed) {\n                        ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));\n                    }\n                }));\n            }\n        });\n        return new Observable(subscriber => {\n            subscribed = true;\n            return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);\n        });\n    };\n}\nclass InternalErrorReporter {\n    constructor(_injector) {\n        this._injector = _injector;\n        /** Will be set lazily to be backward compatible. */\n        this._errorHandler = null;\n    }\n    reportErrorSafely(error) {\n        if (this._errorHandler === null) {\n            this._errorHandler = this._injector.get(ErrorHandler);\n        }\n        // The `try-catch` is used to avoid handling the error twice. Suppose we call\n        // `handleError` which re-throws the error internally. The re-thrown error will\n        // be caught by zone.js which will then get to the `zone.onError.emit()` and the\n        // `onError` subscriber will call `handleError` again.\n        try {\n            this._errorHandler.handleError(error);\n        }\n        catch (_a) { }\n    }\n}\n/** @nocollapse */ InternalErrorReporter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalErrorReporter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass StateStream extends BehaviorSubject {\n    constructor() {\n        super({});\n    }\n    ngOnDestroy() {\n        // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n        // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n        // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n        this.complete();\n    }\n}\n/** @nocollapse */ StateStream.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateStream.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\nclass PluginManager {\n    constructor(_parentManager, _pluginHandlers) {\n        this._parentManager = _parentManager;\n        this._pluginHandlers = _pluginHandlers;\n        this.plugins = [];\n        this.registerHandlers();\n    }\n    get rootPlugins() {\n        return (this._parentManager && this._parentManager.plugins) || this.plugins;\n    }\n    registerHandlers() {\n        const pluginHandlers = this.getPluginHandlers();\n        this.rootPlugins.push(...pluginHandlers);\n    }\n    getPluginHandlers() {\n        const handlers = this._pluginHandlers || [];\n        return handlers.map((plugin) => (plugin.handle ? plugin.handle.bind(plugin) : plugin));\n    }\n}\n/** @nocollapse */ PluginManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager, deps: [{ token: PluginManager, optional: true, skipSelf: true }, { token: NGXS_PLUGINS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ PluginManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: PluginManager, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_PLUGINS]\n                }, {\n                    type: Optional\n                }] }]; } });\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {\n}\n/** @nocollapse */ InternalDispatchedActionResults.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalDispatchedActionResults.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults, decorators: [{\n            type: Injectable\n        }] });\nclass InternalDispatcher {\n    constructor(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {\n        this._actions = _actions;\n        this._actionResults = _actionResults;\n        this._pluginManager = _pluginManager;\n        this._stateStream = _stateStream;\n        this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n        this._internalErrorReporter = _internalErrorReporter;\n    }\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n        const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n        return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));\n    }\n    dispatchByEvents(actionOrActions) {\n        if (Array.isArray(actionOrActions)) {\n            if (actionOrActions.length === 0)\n                return of(this._stateStream.getValue());\n            return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n        }\n        else {\n            return this.dispatchSingle(actionOrActions);\n        }\n    }\n    dispatchSingle(action) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const type = getActionTypeFromInstance(action);\n            if (!type) {\n                const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n                return throwError(error);\n            }\n        }\n        const prevState = this._stateStream.getValue();\n        const plugins = this._pluginManager.plugins;\n        return compose([\n            ...plugins,\n            (nextState, nextAction) => {\n                if (nextState !== prevState) {\n                    this._stateStream.next(nextState);\n                }\n                const actionResult$ = this.getActionResultStream(nextAction);\n                actionResult$.subscribe(ctx => this._actions.next(ctx));\n                this._actions.next({ action: nextAction, status: \"DISPATCHED\" /* Dispatched */ });\n                return this.createDispatchObservable(actionResult$);\n            }\n        ])(prevState, action).pipe(shareReplay());\n    }\n    getActionResultStream(action) {\n        return this._actionResults.pipe(filter((ctx) => ctx.action === action && ctx.status !== \"DISPATCHED\" /* Dispatched */), take(1), shareReplay());\n    }\n    createDispatchObservable(actionResult$) {\n        return actionResult$\n            .pipe(exhaustMap((ctx) => {\n            switch (ctx.status) {\n                case \"SUCCESSFUL\" /* Successful */:\n                    return of(this._stateStream.getValue());\n                case \"ERRORED\" /* Errored */:\n                    return throwError(ctx.error);\n                default:\n                    return EMPTY;\n            }\n        }))\n            .pipe(shareReplay());\n    }\n}\n/** @nocollapse */ InternalDispatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher, deps: [{ token: InternalActions }, { token: InternalDispatchedActionResults }, { token: PluginManager }, { token: StateStream }, { token: InternalNgxsExecutionStrategy }, { token: InternalErrorReporter }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalDispatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: InternalActions }, { type: InternalDispatchedActionResults }, { type: PluginManager }, { type: StateStream }, { type: InternalNgxsExecutionStrategy }, { type: InternalErrorReporter }]; } });\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = (o) => {\n    Object.freeze(o);\n    const oIsFunction = typeof o === 'function';\n    const hasOwnProp = Object.prototype.hasOwnProperty;\n    Object.getOwnPropertyNames(o).forEach(function (prop) {\n        if (hasOwnProp.call(o, prop) &&\n            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n            o[prop] !== null &&\n            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n            !Object.isFrozen(o[prop])) {\n            deepFreeze(o[prop]);\n        }\n    });\n    return o;\n};\n\n/**\n * State Context factory class\n * @ignore\n */\nclass InternalStateOperations {\n    constructor(_stateStream, _dispatcher, _config) {\n        this._stateStream = _stateStream;\n        this._dispatcher = _dispatcher;\n        this._config = _config;\n    }\n    /**\n     * Returns the root state operators.\n     */\n    getRootStateOperations() {\n        const rootStateOperations = {\n            getState: () => this._stateStream.getValue(),\n            setState: (newState) => this._stateStream.next(newState),\n            dispatch: (actionOrActions) => this._dispatcher.dispatch(actionOrActions)\n        };\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            return this._config.developmentMode\n                ? ensureStateAndActionsAreImmutable(rootStateOperations)\n                : rootStateOperations;\n        }\n        else {\n            return rootStateOperations;\n        }\n    }\n    setStateToTheCurrentWithNew(results) {\n        const stateOperations = this.getRootStateOperations();\n        // Get our current stream\n        const currentState = stateOperations.getState();\n        // Set the state to the current + new\n        stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));\n    }\n}\n/** @nocollapse */ InternalStateOperations.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations, deps: [{ token: StateStream }, { token: InternalDispatcher }, { token: NgxsConfig }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalStateOperations.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: StateStream }, { type: InternalDispatcher }, { type: NgxsConfig }]; } });\nfunction ensureStateAndActionsAreImmutable(root) {\n    return {\n        getState: () => root.getState(),\n        setState: value => {\n            const frozenValue = deepFreeze(value);\n            return root.setState(frozenValue);\n        },\n        dispatch: actions => {\n            return root.dispatch(actions);\n        }\n    };\n}\n\nfunction simplePatch(value) {\n    return (existingState) => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (Array.isArray(value)) {\n                throwPatchingArrayError();\n            }\n            else if (typeof value !== 'object') {\n                throwPatchingPrimitiveError();\n            }\n        }\n        const newState = Object.assign({}, existingState);\n        for (const key in value) {\n            // deep clone for patch compatibility\n            newState[key] = value[key];\n        }\n        return newState;\n    };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n    constructor(_internalStateOperations) {\n        this._internalStateOperations = _internalStateOperations;\n    }\n    /**\n     * Create the state context\n     */\n    createStateContext(mappedStore) {\n        const root = this._internalStateOperations.getRootStateOperations();\n        function getState(currentAppState) {\n            return getValue(currentAppState, mappedStore.path);\n        }\n        function setStateValue(currentAppState, newValue) {\n            const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n            root.setState(newAppState);\n            return newAppState;\n            // In doing this refactoring I noticed that there is a 'bug' where the\n            // application state is returned instead of this state slice.\n            // This has worked this way since the beginning see:\n            // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n            // This needs to be fixed, but is a 'breaking' change.\n            // I will do this fix in a subsequent PR and we can decide how to handle it.\n        }\n        function setStateFromOperator(currentAppState, stateOperator) {\n            const local = getState(currentAppState);\n            const newValue = stateOperator(local);\n            return setStateValue(currentAppState, newValue);\n        }\n        function isStateOperator(value) {\n            return typeof value === 'function';\n        }\n        return {\n            getState() {\n                const currentAppState = root.getState();\n                return getState(currentAppState);\n            },\n            patchState(val) {\n                const currentAppState = root.getState();\n                const patchOperator = simplePatch(val);\n                return setStateFromOperator(currentAppState, patchOperator);\n            },\n            setState(val) {\n                const currentAppState = root.getState();\n                return isStateOperator(val)\n                    ? setStateFromOperator(currentAppState, val)\n                    : setStateValue(currentAppState, val);\n            },\n            dispatch(actions) {\n                return root.dispatch(actions);\n            }\n        };\n    }\n}\n/** @nocollapse */ StateContextFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory, deps: [{ token: InternalStateOperations }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateContextFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: InternalStateOperations }]; } });\n\nclass StoreValidators {\n    static checkThatStateIsNamedCorrectly(name) {\n        if (!name) {\n            throwStateNamePropertyError();\n        }\n        else if (!this.stateNameRegex.test(name)) {\n            throwStateNameError(name);\n        }\n    }\n    static checkThatStateNameIsUnique(stateName, state, statesByName) {\n        const existingState = statesByName[stateName];\n        if (existingState && existingState !== state) {\n            throwStateUniqueError(stateName, state.name, existingState.name);\n        }\n    }\n    static checkThatStateClassesHaveBeenDecorated(stateClasses) {\n        stateClasses.forEach((stateClass) => {\n            if (!getStoreMetadata$1(stateClass)) {\n                throwStateDecoratorError(stateClass.name);\n            }\n        });\n    }\n}\nStoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n    // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n    // AOT mode because this property is added before runtime. If an application is running in\n    // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n    // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n    const ngInjectableDef = stateClass.ɵprov;\n    if (!ngInjectableDef) {\n        // Don't warn if Ivy is disabled or `ɵprov` exists on the class\n        console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n    }\n}\n\n/**\n * Init action\n */\nclass InitState {\n    static get type() {\n        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n        return '@@INIT';\n    }\n}\n/**\n * Update action\n */\nclass UpdateState {\n    constructor(addedStates) {\n        this.addedStates = addedStates;\n    }\n    static get type() {\n        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n        return '@@UPDATE_STATE';\n    }\n}\n\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {\n    providedIn: 'root',\n    factory: () => ({ warnOnUnhandledActions: true })\n});\n\nclass NgxsUnhandledActionsLogger {\n    constructor(options) {\n        /**\n         * These actions should be ignored by default; the user can increase this\n         * list in the future via the `ignoreActions` method.\n         */\n        this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n        if (typeof options.warnOnUnhandledActions === 'object') {\n            this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n        }\n    }\n    /**\n     * Adds actions to the internal list of actions that should be ignored.\n     */\n    ignoreActions(...actions) {\n        for (const action of actions) {\n            this._ignoredActions.add(action.type);\n        }\n    }\n    /** @internal */\n    warn(action) {\n        const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n        if (actionShouldBeIgnored) {\n            return;\n        }\n        action =\n            action.constructor && action.constructor.name !== 'Object'\n                ? action.constructor.name\n                : action.type;\n        console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n    }\n}\n/** @nocollapse */ NgxsUnhandledActionsLogger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger, deps: [{ token: NGXS_DEVELOPMENT_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NgxsUnhandledActionsLogger.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_DEVELOPMENT_OPTIONS]\n                }] }]; } });\n\n/**\n * State factory class\n * @ignore\n */\nclass StateFactory {\n    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n        this._injector = _injector;\n        this._config = _config;\n        this._parentFactory = _parentFactory;\n        this._actions = _actions;\n        this._actionResults = _actionResults;\n        this._stateContextFactory = _stateContextFactory;\n        this._initialState = _initialState;\n        this._actionsSubscription = null;\n        this._states = [];\n        this._statesByName = {};\n        this._statePaths = {};\n        this.getRuntimeSelectorContext = memoize(() => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const stateFactory = this;\n            function resolveGetter(key) {\n                const path = stateFactory.statePaths[key];\n                return path ? propGetter(path.split('.'), stateFactory._config) : null;\n            }\n            const context = this._parentFactory\n                ? this._parentFactory.getRuntimeSelectorContext()\n                : {\n                    getStateGetter(key) {\n                        let getter = resolveGetter(key);\n                        if (getter) {\n                            return getter;\n                        }\n                        return (...args) => {\n                            // Late loaded getter\n                            if (!getter) {\n                                getter = resolveGetter(key);\n                            }\n                            return getter ? getter(...args) : undefined;\n                        };\n                    },\n                    getSelectorOptions(localOptions) {\n                        const globalSelectorOptions = stateFactory._config.selectorOptions;\n                        return Object.assign(Object.assign({}, globalSelectorOptions), (localOptions || {}));\n                    }\n                };\n            return context;\n        });\n    }\n    get states() {\n        return this._parentFactory ? this._parentFactory.states : this._states;\n    }\n    get statesByName() {\n        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n    }\n    get statePaths() {\n        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n    }\n    static cloneDefaults(defaults) {\n        let value = {};\n        if (Array.isArray(defaults)) {\n            value = defaults.slice();\n        }\n        else if (isObject$1(defaults)) {\n            value = Object.assign({}, defaults);\n        }\n        else if (defaults === undefined) {\n            value = {};\n        }\n        else {\n            value = defaults;\n        }\n        return value;\n    }\n    ngOnDestroy() {\n        // This is being non-null asserted since `_actionsSubscrition` is\n        // initialized within the constructor.\n        this._actionsSubscription.unsubscribe();\n    }\n    /**\n     * Add a new state to the global defs.\n     */\n    add(stateClasses) {\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);\n        }\n        const { newStates } = this.addToStatesMap(stateClasses);\n        if (!newStates.length)\n            return [];\n        const stateGraph = buildGraph(newStates);\n        const sortedStates = topologicalSort(stateGraph);\n        const paths = findFullParentPath(stateGraph);\n        const nameGraph = nameToState(newStates);\n        const bootstrappedStores = [];\n        for (const name of sortedStates) {\n            const stateClass = nameGraph[name];\n            const path = paths[name];\n            const meta = stateClass[META_KEY];\n            this.addRuntimeInfoToMeta(meta, path);\n            // Note: previously we called `ensureStateClassIsInjectable` within the\n            // `State` decorator. This check is moved here because the `ɵprov` property\n            // will not exist on the class in JIT mode (because it's set asynchronously\n            // during JIT compilation through `Object.defineProperty`).\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                ensureStateClassIsInjectable(stateClass);\n            }\n            const stateMap = {\n                name,\n                path,\n                isInitialised: false,\n                actions: meta.actions,\n                instance: this._injector.get(stateClass),\n                defaults: StateFactory.cloneDefaults(meta.defaults)\n            };\n            // ensure our store hasn't already been added\n            // but don't throw since it could be lazy\n            // loaded from different paths\n            if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n                bootstrappedStores.push(stateMap);\n            }\n            this.states.push(stateMap);\n        }\n        return bootstrappedStores;\n    }\n    /**\n     * Add a set of states to the store and return the defaults\n     */\n    addAndReturnDefaults(stateClasses) {\n        const classes = stateClasses || [];\n        const mappedStores = this.add(classes);\n        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n        return { defaults, states: mappedStores };\n    }\n    /**\n     * Bind the actions to the handlers\n     */\n    connectActionHandlers() {\n        if (this._actionsSubscription !== null)\n            return;\n        const dispatched$ = new Subject();\n        this._actionsSubscription = this._actions\n            .pipe(filter((ctx) => ctx.status === \"DISPATCHED\" /* Dispatched */), mergeMap(ctx => {\n            dispatched$.next(ctx);\n            const action = ctx.action;\n            return this.invokeActions(dispatched$, action).pipe(map(() => ({ action, status: \"SUCCESSFUL\" /* Successful */ })), defaultIfEmpty({ action, status: \"CANCELED\" /* Canceled */ }), catchError(error => of({ action, status: \"ERRORED\" /* Errored */, error })));\n        }))\n            .subscribe(ctx => this._actionResults.next(ctx));\n    }\n    /**\n     * Invoke actions on the states.\n     */\n    invokeActions(dispatched$, action) {\n        const type = getActionTypeFromInstance(action);\n        const results = [];\n        // Determines whether the dispatched action has been handled, this is assigned\n        // to `true` within the below `for` loop if any `actionMetas` has been found.\n        let actionHasBeenHandled = false;\n        for (const metadata of this.states) {\n            const actionMetas = metadata.actions[type];\n            if (actionMetas) {\n                for (const actionMeta of actionMetas) {\n                    const stateContext = this._stateContextFactory.createStateContext(metadata);\n                    try {\n                        let result = metadata.instance[actionMeta.fn](stateContext, action);\n                        if (result instanceof Promise) {\n                            result = from(result);\n                        }\n                        if (isObservable(result)) {\n                            // If this observable has been completed w/o emitting\n                            // any value then we wouldn't want to complete the whole chain\n                            // of actions. Since if any observable completes then\n                            // action will be canceled.\n                            // For instance if any action handler would've had such statement:\n                            // `handler(ctx) { return EMPTY; }`\n                            // then the action will be canceled.\n                            // See https://github.com/ngxs/store/issues/1568\n                            result = result.pipe(mergeMap((value) => {\n                                if (value instanceof Promise) {\n                                    return from(value);\n                                }\n                                if (isObservable(value)) {\n                                    return value;\n                                }\n                                return of(value);\n                            }), defaultIfEmpty({}));\n                            if (actionMeta.options.cancelUncompleted) {\n                                // todo: ofActionDispatched should be used with action class\n                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n                            }\n                        }\n                        else {\n                            result = of({}).pipe(shareReplay());\n                        }\n                        results.push(result);\n                    }\n                    catch (e) {\n                        results.push(throwError(e));\n                    }\n                    actionHasBeenHandled = true;\n                }\n            }\n        }\n        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n        // only during development.\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !actionHasBeenHandled) {\n            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n            // didn't return `null` so we may ensure the module has been imported.\n            if (unhandledActionsLogger) {\n                unhandledActionsLogger.warn(action);\n            }\n        }\n        if (!results.length) {\n            results.push(of({}));\n        }\n        return forkJoin(results);\n    }\n    addToStatesMap(stateClasses) {\n        const newStates = [];\n        const statesMap = this.statesByName;\n        for (const stateClass of stateClasses) {\n            const stateName = getStoreMetadata$1(stateClass).name;\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);\n            }\n            const unmountedState = !statesMap[stateName];\n            if (unmountedState) {\n                newStates.push(stateClass);\n                statesMap[stateName] = stateClass;\n            }\n        }\n        return { newStates };\n    }\n    addRuntimeInfoToMeta(meta, path) {\n        this.statePaths[meta.name] = path;\n        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n        // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n        // We will need to come up with an alternative in v4 because this is used by many plugins\n        meta.path = path;\n    }\n    /**\n     * @description\n     * the method checks if the state has already been added to the tree\n     * and completed the life cycle\n     * @param name\n     * @param path\n     */\n    hasBeenMountedAndBootstrapped(name, path) {\n        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n        return this.statesByName[name] && valueIsBootstrappedInInitialState;\n    }\n}\n/** @nocollapse */ StateFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory, deps: [{ token: i0.Injector }, { token: NgxsConfig }, { token: StateFactory, optional: true, skipSelf: true }, { token: InternalActions }, { token: InternalDispatchedActionResults }, { token: StateContextFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: NgxsConfig }, { type: StateFactory, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: InternalActions }, { type: InternalDispatchedActionResults }, { type: StateContextFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [INITIAL_STATE_TOKEN]\n                }] }]; } });\n\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n    getOptions: (target) => {\n        return (target && target[SELECTOR_OPTIONS_META_KEY]) || {};\n    },\n    defineOptions: (target, options) => {\n        if (!target)\n            return;\n        target[SELECTOR_OPTIONS_META_KEY] = options;\n    }\n};\n/**\n * Function for creating a selector\n * @param selectors The selectors to use to create the arguments of this function\n * @param originalFn The original function being made into a selector\n * @param creationMetadata\n */\nfunction createSelector(selectors, originalFn, creationMetadata) {\n    const containerClass = creationMetadata && creationMetadata.containerClass;\n    const wrappedFn = function wrappedSelectorFn(...args) {\n        const returnValue = originalFn.apply(containerClass, args);\n        if (returnValue instanceof Function) {\n            const innerMemoizedFn = memoize.apply(null, [returnValue]);\n            return innerMemoizedFn;\n        }\n        return returnValue;\n    };\n    const memoizedFn = memoize(wrappedFn);\n    Object.setPrototypeOf(memoizedFn, originalFn);\n    const selectorMetaData = setupSelectorMetadata(originalFn, creationMetadata);\n    const makeRootSelector = (context) => {\n        const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n        return function selectFromRoot(rootState) {\n            // Determine arguments from the app state using the selectors\n            const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n            // if the lambda tries to access a something on the\n            // state that doesn't exist, it will throw a TypeError.\n            // since this is quite usual behaviour, we simply return undefined if so.\n            try {\n                return memoizedFn(...results);\n            }\n            catch (ex) {\n                if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n                    return undefined;\n                }\n                throw ex;\n            }\n        };\n    };\n    selectorMetaData.makeRootSelector = makeRootSelector;\n    return memoizedFn;\n}\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n    const selectorMetaData = ensureSelectorMetadata$1(originalFn);\n    selectorMetaData.originalFn = originalFn;\n    let getExplicitSelectorOptions = () => ({});\n    if (creationMetadata) {\n        selectorMetaData.containerClass = creationMetadata.containerClass;\n        selectorMetaData.selectorName = creationMetadata.selectorName;\n        getExplicitSelectorOptions =\n            creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n    }\n    const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n    selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n    return selectorMetaData;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n    const localSelectorOptions = selectorMetaData.getSelectorOptions();\n    const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n    const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n    const argumentSelectorFunctions = selectorsToApply.map(selector => {\n        const factory = getRootSelectorFactory(selector);\n        return factory(context);\n    });\n    return {\n        selectorOptions,\n        argumentSelectorFunctions\n    };\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, (selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {})), (selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {})), (selectorMetaData.getSelectorOptions() || {})), explicitOptions);\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n    const selectorsToApply = [];\n    const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n    if (containerClass && canInjectContainerState) {\n        // If we are on a state class, add it as the first selector parameter\n        const metadata = getStoreMetadata$1(containerClass);\n        if (metadata) {\n            selectorsToApply.push(containerClass);\n        }\n    }\n    if (selectors) {\n        selectorsToApply.push(...selectors);\n    }\n    return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n    const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n    return (metadata && metadata.makeRootSelector) || (() => selector);\n}\n\n// tslint:disable:unified-signatures\nclass Store {\n    constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n        this._stateStream = _stateStream;\n        this._internalStateOperations = _internalStateOperations;\n        this._config = _config;\n        this._internalExecutionStrategy = _internalExecutionStrategy;\n        this._stateFactory = _stateFactory;\n        /**\n         * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n         * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n         * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n         */\n        this._selectableStateStream = this._stateStream.pipe(observeOn(queueScheduler), leaveNgxs(this._internalExecutionStrategy), shareReplay({ bufferSize: 1, refCount: true }));\n        this.initStateStream(initialStateValue);\n    }\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n        return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n    }\n    select(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return this._selectableStateStream.pipe(map(selectorFn), catchError((err) => {\n            // if error is TypeError we swallow it to prevent usual errors with property access\n            const { suppressErrors } = this._config.selectorOptions;\n            if (err instanceof TypeError && suppressErrors) {\n                return of(undefined);\n            }\n            // rethrow other errors\n            return throwError(err);\n        }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n    }\n    selectOnce(selector) {\n        return this.select(selector).pipe(take(1));\n    }\n    selectSnapshot(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return selectorFn(this._stateStream.getValue());\n    }\n    /**\n     * Allow the user to subscribe to the root of the state\n     */\n    subscribe(fn) {\n        return this._selectableStateStream\n            .pipe(leaveNgxs(this._internalExecutionStrategy))\n            .subscribe(fn);\n    }\n    /**\n     * Return the raw value of the state.\n     */\n    snapshot() {\n        return this._internalStateOperations.getRootStateOperations().getState();\n    }\n    /**\n     * Reset the state to a specific point in time. This method is useful\n     * for plugin's who need to modify the state directly or unit testing.\n     */\n    reset(state) {\n        return this._internalStateOperations.getRootStateOperations().setState(state);\n    }\n    getStoreBoundSelectorFn(selector) {\n        const makeSelectorFn = getRootSelectorFactory(selector);\n        const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n        return makeSelectorFn(runtimeContext);\n    }\n    initStateStream(initialStateValue) {\n        const value = this._stateStream.value;\n        const storeIsEmpty = !value || Object.keys(value).length === 0;\n        if (storeIsEmpty) {\n            const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n            const storeValues = defaultStateNotEmpty\n                ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;\n            this._stateStream.next(storeValues);\n        }\n    }\n}\n/** @nocollapse */ Store.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store, deps: [{ token: StateStream }, { token: InternalStateOperations }, { token: NgxsConfig }, { token: InternalNgxsExecutionStrategy }, { token: StateFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ Store.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: StateStream }, { type: InternalStateOperations }, { type: NgxsConfig }, { type: InternalNgxsExecutionStrategy }, { type: StateFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [INITIAL_STATE_TOKEN]\n                }] }]; } });\n\nclass LifecycleStateManager {\n    constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {\n        this._store = _store;\n        this._internalErrorReporter = _internalErrorReporter;\n        this._internalStateOperations = _internalStateOperations;\n        this._stateContextFactory = _stateContextFactory;\n        this._bootstrapper = _bootstrapper;\n        this._destroy$ = new Subject();\n    }\n    ngOnDestroy() {\n        this._destroy$.next();\n    }\n    ngxsBootstrap(action, results) {\n        this._internalStateOperations\n            .getRootStateOperations()\n            .dispatch(action)\n            .pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {\n            // The `SafeSubscriber` (which is used by most RxJS operators) re-throws\n            // errors asynchronously (`setTimeout(() => { throw error })`). This might\n            // break existing user's code or unit tests. We catch the error manually to\n            // be backward compatible with the old behavior.\n            this._internalErrorReporter.reportErrorSafely(error);\n            return EMPTY;\n        }), takeUntil(this._destroy$))\n            .subscribe(() => this._invokeBootstrapOnStates(results.states));\n    }\n    _invokeInitOnStates(mappedStores) {\n        for (const mappedStore of mappedStores) {\n            const instance = mappedStore.instance;\n            if (instance.ngxsOnChanges) {\n                this._store\n                    .select(state => getValue(state, mappedStore.path))\n                    .pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$))\n                    .subscribe(([previousValue, currentValue]) => {\n                    const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n                    instance.ngxsOnChanges(change);\n                });\n            }\n            if (instance.ngxsOnInit) {\n                instance.ngxsOnInit(this._getStateContext(mappedStore));\n            }\n            mappedStore.isInitialised = true;\n        }\n    }\n    _invokeBootstrapOnStates(mappedStores) {\n        for (const mappedStore of mappedStores) {\n            const instance = mappedStore.instance;\n            if (instance.ngxsAfterBootstrap) {\n                instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n            }\n        }\n    }\n    _getStateContext(mappedStore) {\n        return this._stateContextFactory.createStateContext(mappedStore);\n    }\n}\n/** @nocollapse */ LifecycleStateManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager, deps: [{ token: Store }, { token: InternalErrorReporter }, { token: InternalStateOperations }, { token: StateContextFactory }, { token: i5.NgxsBootstrapper }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ LifecycleStateManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: Store }, { type: InternalErrorReporter }, { type: InternalStateOperations }, { type: StateContextFactory }, { type: i5.NgxsBootstrapper }]; } });\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n    constructor(store, config) {\n        SelectFactory.store = store;\n        SelectFactory.config = config;\n    }\n    ngOnDestroy() {\n        SelectFactory.store = null;\n        SelectFactory.config = null;\n    }\n}\nSelectFactory.store = null;\nSelectFactory.config = null;\n/** @nocollapse */ SelectFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory, deps: [{ token: Store }, { token: NgxsConfig }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ SelectFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: Store }, { type: NgxsConfig }]; } });\n\n/**\n * Root module\n * @ignore\n */\nclass NgxsRootModule {\n    constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n        // Add stores to the state graph and return their defaults\n        const results = factory.addAndReturnDefaults(states);\n        internalStateOperations.setStateToTheCurrentWithNew(results);\n        // Connect our actions stream\n        factory.connectActionHandlers();\n        // Dispatch the init action and invoke init and bootstrap functions after\n        lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n    }\n}\n/** @nocollapse */ NgxsRootModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule, deps: [{ token: StateFactory }, { token: InternalStateOperations }, { token: Store }, { token: SelectFactory }, { token: ROOT_STATE_TOKEN, optional: true }, { token: LifecycleStateManager }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsRootModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule });\n/** @nocollapse */ NgxsRootModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: StateFactory }, { type: InternalStateOperations }, { type: Store }, { type: SelectFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [ROOT_STATE_TOKEN]\n                }] }, { type: LifecycleStateManager }]; } });\n\n/**\n * Feature module\n * @ignore\n */\nclass NgxsFeatureModule {\n    constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n        // Since FEATURE_STATE_TOKEN is a multi token, we need to\n        // flatten it [[Feature1State, Feature2State], [Feature3State]]\n        const flattenedStates = NgxsFeatureModule.flattenStates(states);\n        // add stores to the state graph and return their defaults\n        const results = factory.addAndReturnDefaults(flattenedStates);\n        if (results.states.length) {\n            internalStateOperations.setStateToTheCurrentWithNew(results);\n            // dispatch the update action and invoke init and bootstrap functions after\n            lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n        }\n    }\n    static flattenStates(states = []) {\n        return states.reduce((total, values) => total.concat(values), []);\n    }\n}\n/** @nocollapse */ NgxsFeatureModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule, deps: [{ token: Store }, { token: InternalStateOperations }, { token: StateFactory }, { token: FEATURE_STATE_TOKEN, optional: true }, { token: LifecycleStateManager }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsFeatureModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule });\n/** @nocollapse */ NgxsFeatureModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: Store }, { type: InternalStateOperations }, { type: StateFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FEATURE_STATE_TOKEN]\n                }] }, { type: LifecycleStateManager }]; } });\n\n/**\n * Ngxs Module\n */\nclass NgxsModule {\n    /**\n     * Root module factory\n     */\n    static forRoot(states = [], options = {}) {\n        return {\n            ngModule: NgxsRootModule,\n            providers: [\n                StateFactory,\n                StateContextFactory,\n                Actions,\n                InternalActions,\n                NgxsBootstrapper,\n                LifecycleStateManager,\n                InternalDispatcher,\n                InternalDispatchedActionResults,\n                InternalStateOperations,\n                InternalNgxsExecutionStrategy,\n                Store,\n                StateStream,\n                SelectFactory,\n                PluginManager,\n                ...states,\n                ...NgxsModule.ngxsTokenProviders(states, options)\n            ]\n        };\n    }\n    /**\n     * Feature module factory\n     */\n    static forFeature(states = []) {\n        return {\n            ngModule: NgxsFeatureModule,\n            providers: [\n                StateFactory,\n                PluginManager,\n                ...states,\n                {\n                    provide: FEATURE_STATE_TOKEN,\n                    multi: true,\n                    useValue: states\n                }\n            ]\n        };\n    }\n    static ngxsTokenProviders(states, options) {\n        return [\n            {\n                provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n                useValue: options.executionStrategy\n            },\n            {\n                provide: ROOT_STATE_TOKEN,\n                useValue: states\n            },\n            {\n                provide: NgxsModule.ROOT_OPTIONS,\n                useValue: options\n            },\n            {\n                provide: NgxsConfig,\n                useFactory: NgxsModule.ngxsConfigFactory,\n                deps: [NgxsModule.ROOT_OPTIONS]\n            },\n            {\n                provide: APP_BOOTSTRAP_LISTENER,\n                useFactory: NgxsModule.appBootstrapListenerFactory,\n                multi: true,\n                deps: [NgxsBootstrapper]\n            },\n            {\n                provide: INITIAL_STATE_TOKEN,\n                useFactory: NgxsModule.getInitialState\n            },\n            {\n                provide: ɵNGXS_STATE_CONTEXT_FACTORY,\n                useExisting: StateContextFactory\n            },\n            {\n                provide: ɵNGXS_STATE_FACTORY,\n                useExisting: StateFactory\n            }\n        ];\n    }\n    static ngxsConfigFactory(options) {\n        return mergeDeep(new NgxsConfig(), options);\n    }\n    static appBootstrapListenerFactory(bootstrapper) {\n        return () => bootstrapper.bootstrap();\n    }\n    static getInitialState() {\n        return InitialState.pop();\n    }\n}\nNgxsModule.ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\n/** @nocollapse */ NgxsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule });\n/** @nocollapse */ NgxsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule, decorators: [{\n            type: NgModule\n        }] });\n\n/**\n * Decorates a method with a action information.\n */\nfunction Action(actions, options) {\n    return (target, name) => {\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const isStaticMethod = target.hasOwnProperty('prototype');\n            if (isStaticMethod) {\n                throwActionDecoratorError();\n            }\n        }\n        const meta = ensureStoreMetadata$1(target.constructor);\n        if (!Array.isArray(actions)) {\n            actions = [actions];\n        }\n        for (const action of actions) {\n            const type = action.type;\n            if (!meta.actions[type]) {\n                meta.actions[type] = [];\n            }\n            meta.actions[type].push({\n                fn: name,\n                options: options || {},\n                type\n            });\n        }\n    };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n    function getStateOptions(inheritedStateClass) {\n        const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n        return Object.assign(Object.assign({}, inheritanceOptions), options);\n    }\n    function mutateMetaData(params) {\n        const { meta, inheritedStateClass, optionsWithInheritance } = params;\n        const { children, defaults, name } = optionsWithInheritance;\n        const stateName = typeof name === 'string' ? name : (name && name.getName()) || null;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            StoreValidators.checkThatStateIsNamedCorrectly(stateName);\n        }\n        if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n            const inheritedMeta = inheritedStateClass[META_KEY] || {};\n            meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);\n        }\n        meta.children = children;\n        meta.defaults = defaults;\n        meta.name = stateName;\n    }\n    return (target) => {\n        const stateClass = target;\n        const meta = ensureStoreMetadata$1(stateClass);\n        const inheritedStateClass = Object.getPrototypeOf(stateClass);\n        const optionsWithInheritance = getStateOptions(inheritedStateClass);\n        mutateMetaData({ meta, inheritedStateClass, optionsWithInheritance });\n        stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n    };\n}\n\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n    if (!SelectFactory.store) {\n        throwSelectFactoryNotConnectedError();\n    }\n    return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n    rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n    if (typeof rawSelector === 'string') {\n        const propsArray = paths.length\n            ? [rawSelector, ...paths]\n            : rawSelector.split('.');\n        return propGetter(propsArray, SelectFactory.config);\n    }\n    return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n    const lastCharIndex = name.length - 1;\n    const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nfunction Select(rawSelector, ...paths) {\n    return function (target, key) {\n        const name = key.toString();\n        const selectorId = `__${name}__selector`;\n        const selector = createSelectorFn(name, rawSelector, paths);\n        Object.defineProperties(target, {\n            [selectorId]: {\n                writable: true,\n                enumerable: false,\n                configurable: true\n            },\n            [name]: {\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n                }\n            }\n        });\n    };\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n    return (function decorate(target, methodName, descriptor) {\n        if (methodName) {\n            descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName));\n            // Method Decorator\n            const originalFn = descriptor.value || descriptor.originalFn;\n            if (originalFn) {\n                selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n            }\n        }\n        else {\n            // Class Decorator\n            selectorOptionsMetaAccessor.defineOptions(target, options);\n        }\n    });\n}\n\nfunction ensureStoreMetadata(target) {\n    return ensureStoreMetadata$1(target);\n}\nfunction getStoreMetadata(target) {\n    return getStoreMetadata$1(target);\n}\nfunction ensureSelectorMetadata(target) {\n    return ensureSelectorMetadata$1(target);\n}\nfunction getSelectorMetadata(target) {\n    return getSelectorMetadata$1(target);\n}\n\n/**\n * Decorator for memoizing a state selector.\n */\nfunction Selector(selectors) {\n    return (target, key, descriptor) => {\n        descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));\n        const originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (originalFn && typeof originalFn !== 'function') {\n                throwSelectorDecoratorError();\n            }\n        }\n        const memoizedFn = createSelector(selectors, originalFn, {\n            containerClass: target,\n            selectorName: key.toString(),\n            getSelectorOptions() {\n                return {};\n            },\n        });\n        const newDescriptor = {\n            configurable: true,\n            get() {\n                return memoizedFn;\n            },\n        };\n        // Add hidden property to descriptor\n        newDescriptor['originalFn'] = originalFn;\n        return newDescriptor;\n    };\n}\n\nclass StateToken {\n    constructor(name) {\n        this.name = name;\n        const selectorMetadata = ensureSelectorMetadata$1(this);\n        selectorMetadata.makeRootSelector = (runtimeContext) => {\n            return runtimeContext.getStateGetter(this.name);\n        };\n    }\n    getName() {\n        return this.name;\n    }\n    toString() {\n        return `StateToken[${this.name}]`;\n    }\n}\n\nclass NgxsDevelopmentModule {\n    static forRoot(options) {\n        return {\n            ngModule: NgxsDevelopmentModule,\n            providers: [\n                NgxsUnhandledActionsLogger,\n                { provide: NGXS_DEVELOPMENT_OPTIONS, useValue: options }\n            ]\n        };\n    }\n}\n/** @nocollapse */ NgxsDevelopmentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsDevelopmentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule });\n/** @nocollapse */ NgxsDevelopmentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule, decorators: [{\n            type: NgModule\n        }] });\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createSelector, ensureSelectorMetadata, ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata, getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}